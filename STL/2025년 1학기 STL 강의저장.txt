

==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>



// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>



// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록

	auto now = std::chrono::system_clock::now();		//epoch로부터 경과된 tick 수
	std::cout << "현재시간 - " << now << '\n';

	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	using namespace std::chrono_literals;
	auto now = std::chrono::system_clock::now();		//epoch로부터 경과된 tick 수
	std::cout << "현재시간 - " << now + 9h << '\n';

	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t( now );	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경
	
	std::cout << "현재시간 - " << std::put_time(lt, "%c, %A") << "\n";

	out.imbue(old);											//복구
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 2025-03-10 오후 7:03:28, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t( now );	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << std::put_time(lt, "%c, %A") << '\n';
	out << "==============================================================================================================================\n\n";
	out.imbue(old);											//복구
	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 2025-03-10 오후 7:03:46, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t( now );	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << std::put_time(lt, "%c, %A") << '\n';
	out << "==============================================================================================================================\n\n";
	out.imbue(old);											//복구
	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:37:46, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 실행되게 하라 



int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}




==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:39:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 실행되게 하라 



int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:39:09, 목요일
==============================================================================================================================

#pragma once
//-------------------------------------------------------------------
// save.h
//										         		   2025.03.13
//-------------------------------------------------------------------

void save(std::string_view);

==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:39:09, 목요일
==============================================================================================================================

//-------------------------------------------------------------------
// save.cpp - 한학기 강의를 저장
//														   2025.03.13
//-------------------------------------------------------------------


#include<string_view>
#include<fstream>
#include<iostream>
#include<filesystem>
#include<chrono>
#include "save.h"

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if (not in) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t(now);	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경

	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << std::put_time(lt, "%c, %A") << '\n';
	out << "==============================================================================================================================\n\n";
	out.imbue(old);											//복구
	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}


==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:53:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 

void change(int& x, int& y);


int main() {

	int a{ 1 }, b{ 2 };
	change(a, b); //ab바꾸기

	std::cout << a << ", " << b << std::endl;

	save("main.cpp");

}

void change(int& x, int& y) {
	int temp = x;
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:53:26, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 

void change(int& x, int& y);


int main() {

	int a{ 1 }, b{ 2 };
	change(a, b); //ab바꾸기

	std::cout << a << ", " << b << std::endl;

	save("main.cpp");

}

void change(int& x, int& y) {
	int temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:05:31, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog();
	Dog(int n) {
		age = n;
	}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:06:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog();
	Dog(int n) {
		age = n;
	}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:15:52, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Template
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog(int n) : age{ n } {}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:16:31, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Template
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog() = default;
	Dog(int n) : age{ n } {}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:25:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Template
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog() = default;
	Dog(int n) : age{ n } {}
	friend std::ostream& operator<<(std::ostream& os, const Dog& d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}


==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:39:03, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

//[문제] random한 int 1000개를 화면에 출력하라


int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << rand() << '\n';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:44:10, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid;

int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << uid(dre) << '\n';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:45:42, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << uid(dre) << '\n';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:46:12, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << uid(dre) << ' ';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:48:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:10}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:49:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:<10}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:50:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:^10}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:51:40, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:8}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:04:03, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중ㅇ 가장 큰 값을 찾아 출력하라
int main() {
	int arr[1000];
	int maximum = std::numeric_limits<int>::min();
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		if (arr[i] > maximum) {
			maximum = arr[i];
		}
	}
	std::cout << maximum;
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:04:58, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>
#include<array>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중ㅇ 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum = std::numeric_limits<int>::min();
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		if (arr[i] > maximum) {
			maximum = arr[i];
		}
	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:13:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
	}
	int maximum = arr.max_size();
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:14:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		
	}
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:18:15, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ std::random_device{}() };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		
	}
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:25:31, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		
	}
	
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:25:36, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) { // 1000- magic number, hard-wired coding
		arr[i] = uid(dre);
		
	}
	
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:30:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	for (int num : arr) {
		if (maximum < num)
			maximum = num;
	}

	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:40:14, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	std::max_element(arr.begin(), arr.end());

	for (int num : arr) {
		std::print("{:8}", num);
	}

	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:42:42, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	auto pos = std::max_element(arr.begin(), arr.end());

	for (int num : arr) {
		std::print("{:8}", num);
	}

	std::cout << *pos << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:43:32, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	auto pos = std::max_element(arr.begin(), arr.end());

	for (int num : arr) {
		std::print("{:8}", num);
	}

	std::cout << *pos << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:45:16, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;

	for (int& num : arr) 
		num = uid(dre);
		
	std::cout << *std::max_element(arr.begin(), arr.end()) << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:47:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {
	std::array<int, 1000> arr;

	for (int& num : arr) 
		num = uid(dre);
	std::ofstream out{ "int 1000개.txt" };

	for (int num : arr)
		out << num << " ";

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:53:16, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };

	for (int i =0; i<1000;++i)
		out << uid(dre) << " ";

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:56:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };

	for (int i =0; i<1000;++i)
		out << uid(dre) << " --- ";//---는 구분자(딜리미터)

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:57:26, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };

	for (int i = 0; i < 1000; ++i)
		std::print(out, "{:80}", uid(dre));

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:58:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };
	int counter{};
	for (int i = 0; i < 1000; ++i) {
		std::print(out, "{:80}", uid(dre));
		if (0 == ++counter & 10) {
			out << "\n";
		}
	}
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:59:06, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };
	int counter{};
	for (int i = 0; i < 1000; ++i) {
		std::print(out, "{:80}", uid(dre));
		if (0 == (++counter & 10)) {
			out << "\n";
		}
	}
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:28:36, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	std::ifstream in{ "int 1000개.txt" };
	if (not in) {
		std::cout << "파일을 찾지 못했습니다.\n";
	}
	int num;
	int max_int = std::numeric_limits<int>::min();

	while (in >> num) {
		if (num > max_int)
			max_int = num;
	}
	std::cout << max_int;

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:29:56, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	
	int num{ 0x01020304 };

	std::cout << "2진수 - " << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - " << std::endl;


	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:30:31, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	
	int num{ 0x01020304 };

	std::cout << "2진수 - " << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - " << std::hex << num << std::endl;


	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:33:51, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<bitset>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	
	int num{ 0x01020304 };
	std::bitset<32> binary =  num ;
	std::cout << "2진수 - 0b" << binary << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - 0x" << std::hex << num << std::endl;


	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:51:27, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	for (int i = 0; i < a.size(); ++i) {
		a[i] = i + 1;
	}

	for (int num : a) {
		std::cout << num << " ";

	}
	std::cout << "\n";
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:54:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	std::iota(a.begin(), a.end(), 1);
	for (int num : a) {
		std::cout << num << ' ';
	}
	std::cout << "\n";
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:07:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:08:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 2000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:09:18, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 10000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:10:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(0);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:12:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(10);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:12:53, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(0x0a0a0a0a);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:22:56, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(0x0a0a0a0a);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt", std::ios::binary };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:30:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<random>
//----------------------------------------------------------------------------
// 진짜 랜덤값(non deterministic variable)을 갖는 int 10만개를
// 파일 "진짜 랜덤 10만개"에 저장하였다.
// 파일은 binary모드로 열었고, stream에 write함수를 사용하여 메모리 그대로 저장하였다.


int main() {
	std::random_device rd;

	std::ofstream out{"진짜 랜덤 10만개", std::ios::binary};

	for (int i = 0; i < 100'000; ++i) {
		int num = rd();
		out.write((char*) & num, sizeof(int));

	}

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:52:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}
	int num;
	int cnt{};
	while (in.read((char*)&num, sizeof(int))) {
		++cnt;
	}
	std::cout << cnt << std::endl;
	int max_num = std::numeric_limits<int>::min();
	int min_num = std::numeric_limits<int>::max();
	std::array<int, 100'000> a;
	in.read((char*)a.data(), a.size());
	for (int num : a) {
		if (max_num < num) {
			max_num = num;
		}
		if (min_num > num) {
			min_num = num;
		}
	}

	std::cout << "최대값: " << max_num << std::endl;
	std::cout << "최소값: " << min_num << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:55:22, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최대값: " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "최소값: " << *std::min_element(a.begin(), a.end()) << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:56:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최댓값: " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "최솟값: " << *std::min_element(a.begin(), a.end()) << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:57:16, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최댓값: " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "최솟값: " << *std::min_element(a.begin(), a.end()) << std::endl;
	save("main.cpp");
	
}



==============================================================================================================================
저장한 시간: 2025-03-24 오후 5:20:33, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	auto minmax = std::minmax_element(a.begin(), a.end());

	std::cout << "최댓값: " << *minmax.second<< std::endl;
	std::cout << "최솟값: " << *minmax.first << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:00:50, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

// Dog객체 10만개를 파일 Dog 10만마리에 저장하였다
//

class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};
int main() {

	Dog dog;
	dog.show();

	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:05:11, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

// Dog객체 10만개를 파일 Dog 10만마리에 저장하였다
//

class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};
int main() {

	for (int i = 0; i < 100; ++i) {
		Dog dog;
		dog.show();
	}

	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:10:14, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };



class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};

// Dog객체 10만개를 파일 "Dog 10만마리"에 저장하였다
// 파일은 binary mode로 열었고, Dog객체는 file.write함수를 사용하여 저장하였다.
//

int main() {
	std::ofstream out{ "Dog 10만 마리", std::ios::binary };
	for (int i = 0; i < 100'000; ++i) {
		Dog dog;
		out.write((char*) & dog, sizeof(dog));
	}
	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:11:25, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };



class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};

// Dog객체 10만개를 파일 "Dog 10만마리"에 저장하였다
// 파일은 binary mode로 열었고, Dog객체는 file.write함수를 사용하여 저장하였다.
//

int main() {
	std::ofstream out{ "Dog 10만 마리", std::ios::binary };
	for (int i = 0; i < 100'000; ++i) {
		Dog dog;
		out.write((char*) & dog, sizeof(dog));
	}
	
	save("main.cpp");
	
}



==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:34:00, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 제일 마지막 객첼f cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};
std::array < Dog, 100'000> dogs;
int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());
	std::cout << dogs[dogs.size()-1];
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:37:13, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 제일 마지막 객첼f cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());
	std::cout << dogs[dogs.size()-1];
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:39:18, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 제일 마지막 객첼f cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());
	std::cout << dogs.back();
	save("main.cpp");
	
}



==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:44:23, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 모든 객체를 화면에 cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());

	for (const Dog& d : dogs) {
		std::cout << d << std::endl;
	}
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:58:16, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// 메인코드가 수정없이 실행 될 수 있도록 필요한 코딩을 추가하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		
		return is.read((char*)&dog, sizeof(dog));
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}

	for (int i = 0; i < dogs.size(); ++i) {
		in >> dogs[i];
	}

	//출력
	for (const Dog& dog : dogs) {
		std::cout << dog;
	}

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:51:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:52:36, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:52:44, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:54:48, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		while (getchar() != '\n');
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:09:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	
	

	while (true) {
		int num{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		while (getchar() != '\n');
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		long long acc = std::accumulate(a, a + num, 0);
		
		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:15:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[5];
	std::cout << "address - " << p << "---->";
	for (int i = 0; i < 5; ++i) {
		std:: cout << p[i] << " 0";

	}
	std::cout << std::endl;
}
int main() {

	f();

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:15:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[5];
	std::cout << "address - " << p << "---->";
	for (int i = 0; i < 5; ++i) {
		std:: cout << p[i] << " ";

	}
	std::cout << std::endl;
}
int main() {

	f();

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:16:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[5];
	std::cout << "address - " << p << "---->";
	for (int i = 0; i < 5; ++i) {
		std:: cout << p[i] << " ";

	}
	std::cout << std::endl;
	delete[] p;
}
int main() {
	for (int i = 0; i < 10; ++i)
		f();

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:25:14, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[200'000'000];


}
int main() {
	try{
		while (true) {
			f();
		}
	}
	catch(const std::exception& e){
		std::cout << e.what() << std::endl;
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:37:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
private:
};

void f() {
	Dog dog;

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:39:48, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
private:
};

void f() {
	Dog* p = new Dog;

	throw 20250327;

	delete p;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:45:39, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

class 스마트 {
public:
	스마트(Dog* p) : p{ p } {}
	~스마트() {
		delete p;
	}
private:
	Dog* p;
};



void f() {
	스마트 p{ new Dog };

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:53:06, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog> p{ new Dog };

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:53:42, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog[]> p{new Dog[10]};

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:54:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog[]> p{new Dog[10]};
	std::cout << "끝난다\n";
}
int main() {
	f();
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:56:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog[]> p = std::make_unique<Dog[]>(10);
	std::cout << "끝난다\n";
}
int main() {
	f();
	save("main.cpp");
	
	
}



==============================================================================================================================
저장한 시간: 2025-03-31 오후 5:35:45, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
//----------------------------------------------------------------------------

// [문제] main.cpp파일을 소문자를 대문자로 전부 변환하여 "main 대문자.cpp"에 저장하라
//
int main() {
	std::ifstream in{ "main.cpp" };
	if (not in) {
		return 02020202;
	}
	std::ofstream out{ "main 대문자.cpp" };
	char c;
	in >> std::noskipws;
	
	while (in >> c) {
		if (islower(c)) 
			c = toupper(c);
		out << c;
		
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 5:51:17, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

// [문제] main.cpp파일을 소문자를 대문자로 전부 변환하여 "main 대문자.cpp"에 저장하라
//
int main() {
	std::ifstream in{ "main.cpp" };
	if (not in) {
		return 02020202;
	}
	std::ofstream out{ "main 대문자.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {},
		std::ostreambuf_iterator<char>{std::cout}, [](char c) {
			return toupper(c);
		});

	save("main.cpp");
	
	
}



==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:12:53, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;
int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	
	qsort(arr.data(),arr.size(), sizeof(int), 
		[](const void* a, const void* b) {
			return *(int*)a - *(int*)b;
		});
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", arr[i]);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:18:24, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;
int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	
	qsort(arr.data(),arr.size(), sizeof(int), 
		[](const void* a, const void* b) {
			return *(int*)a - *(int*)b;
		});
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:35:00, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include "main.h"
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int 오름차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x < y)
		return -1;
	else if(x > y)
		return 1;
	return 0;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	qsort(arr.data(), arr.size(), sizeof(std::array<int, 10'000'000>::value_type),
		//[](const void* a, const void* b) {
		//	return *(int*)a - *(int*)b; // 오름차순
		//	//return *(int*)b - *(int*)a; //내림차순
		//}
		오름차순
	);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:51:27, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int 오름차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x < y)
		return -1;
	else if(x > y)
		return 1;
	return 0;
}
int 내림차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x > y)
		return -1;
	else if (x < y)
		return 1;
	return 0;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	int(*정렬방법)(const void*, const void*) = (int(*)(const void*, const void*))오름차순;

	qsort(arr.data(), arr.size(), sizeof(int), 정렬방법);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:51:40, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int 오름차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x < y)
		return -1;
	else if(x > y)
		return 1;
	return 0;
}
int 내림차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x > y)
		return -1;
	else if (x < y)
		return 1;
	return 0;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	int(*정렬방법)(const void*, const void*) = (int(*)(const void*, const void*))내림차순;

	qsort(arr.data(), arr.size(), sizeof(int), 정렬방법);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:53:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;


int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	sort(arr.begin(), arr.end());
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 7:02:30, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬
	sort(arr.begin(), arr.end(), 내림차순);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 7:04:54, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "정렬시간: " << e - b << std::endl;
	
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 5:34:46, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(arr.begin(), arr.end());					//default는 오른차순
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "정렬시간: " << e - b << std::endl;
	std::cout << "정렬시간(ms): " << std::chrono::duration_cast<std::chrono::milliseconds > (e - b) << std::endl;
	
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-04-03 오후 5:46:00, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "내림차순 정렬시간    : " << e - b << std::endl;

	{
		for (int& i : arr) {
			i = uid(dre);
		}
		//sort로 내림차순 정렬 
		//아마 대부분 lambda로 코딩할거임
		auto b = std::chrono::high_resolution_clock::now();
		sort(arr.begin(), arr.end(), [](int a, int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "내림차순 정렬시간(람다): " << e - b << std::endl;
		

	}
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:06:08, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "내림차순 정렬시간        : " << e - b << std::endl;

	{
		for (int& i : arr) {
			i = uid(dre);
		}
		//sort로 내림차순 정렬 
		//아마 대부분 lambda로 코딩할거임
		auto b = std::chrono::high_resolution_clock::now();
		sort(arr.begin(), arr.end(), [](int a, int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "내림차순 정렬시간(람다): " << e - b << std::endl;
		

	}
	for (int num : arr | std::views::take(10000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:08:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "내림차순 정렬시간      : " << e - b << std::endl;

	{
		for (int& i : arr) {
			i = uid(dre);
		}
		//sort로 내림차순 정렬 
		//아마 대부분 lambda로 코딩할거임
		auto b = std::chrono::high_resolution_clock::now();
		sort(arr.begin(), arr.end(), [](int a, int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "내림차순 정렬시간(람다): " << e - b << std::endl;
		

	}
	for (int num : arr | std::views::reverse | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:13:16, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	
	std::cout << "lambda의 정체" << typeid([]() {}).name() << std::endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:22:37, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면
	class 람다 {
	public:
		void operator()(){
			std::cout << "나는 람다야" << std::endl;
		};
	};
	//로 변환한다
	람다 f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:23:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면
	class 람다 {
	public:
		void operator()(){
			std::cout << "나는 람다야" << std::endl;
		};
	};
	//로 변환한다
	람다 f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:23:49, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면
	class XYZ {
	public:
		void operator()(){
			std::cout << "나는 람다야" << std::endl;
		};
	};
	//로 변환한다
	XYZ f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:24:25, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class XYZ {
public:
	void operator()() {
		std::cout << "나는 람다야" << std::endl;
	};
};

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면

	//로 변환한다
	XYZ f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:29:05, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	Dog dog;

	dog(1);//이것도 오버로딩 가능 operator() - function call operator

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:34:21, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
// 2.함수포인터
// 3.람다 - 이름없는 함수인데, vs에서는 함수 객체를 이용하여 람다를 구현
// 4.함수객체(function object) - 함수호출 연산자를 오버로딩한 클래스의 객체
// 5.멤버함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	int a;
	int b;

	a = b;			//두 변수의 타입이 같다면 이 문장은 항상 참이다

	Dog dog;

	dog(1);			//이것도 오버로딩 가능 operator() - function call operator

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:43:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수 - 함수
// 2.함수포인터 - 함수
// 3.람다 - 이름없는 함수인데, vs에서는 함수 객체를 이용하여 람다를 구현
// 4.함수객체(function object) - 함수호출 연산자를 오버로딩한 클래스의 객체
// 5.멤버함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	//void a(int);
	//void b(int);

	//void(*f)(int) = a;
	//f = b;
	////f가 a, b 모두 담을 수 있다면 a는 b와 같은 형식?


	Dog dog;

	dog(1);			//이것도 오버로딩 가능 operator() - function call operator

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:47:22, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
// 1.함수 - 함수
// 2.함수포인터 - 함수
// 3.람다 - 이름없는 함수인데, vs에서는 함수 객체를 이용하여 람다를 구현
// 4.함수객체(function object) - 함수호출 연산자를 오버로딩한 클래스의 객체
// 5.멤버함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<functional>
//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	//std::sort(b, e, std::function<int(int, int)> f); //실제론 이렇게 하진 않음


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:51:04, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------

class Dog {
public:
	bool operator()(int a, int b) const {
		return a < b;
	}
};

// [문제] 오름차순으로 정렬되게 하라
int main() {
	
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	Dog dog;

	std::sort(a.begin(), a.end(), dog);

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:52:13, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------

class Dog {
public:
	bool operator()(int a, int b) const {
		return a < b;
	}
};

// [문제] 오름차순으로 정렬되게 하라
int main() {
	
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	Dog dog;

	std::sort(a.begin(), a.end(), dog);
	
	for (int num : a)
		std::cout << num;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 7:01:27, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<random>
#include<fstream>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid;
std::uniform_int_distribution uidLen{ 3, 59 };
std::uniform_int_distribution<int> uidName{ 'a', 'z'};

// [과제] Dog객체 10만개를 파일 Dog 10만마리에 저장한다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
// 로 저장하였다
//

class Dog {
public:
	Dog() {
		num = uid(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	};

private:
	size_t num;			//랜덤인트
	std::string name;	//[3, 60)까지의 랜덤 소문자로만 구성

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

};

int main() {
	for (int i = 0; i < 10; ++i) {
		Dog dog;
		std::cout << dog << std::endl;
	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 7:02:49, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<random>
#include<fstream>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid;
std::uniform_int_distribution uidLen{ 3, 59 };
std::uniform_int_distribution<int> uidName{ 'a', 'z'};

// [과제] Dog객체 10만개를 파일 Dog 10만마리에 저장한다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
// 로 저장하였다
//

class Dog {
public:
	Dog() {
		num = uid(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	};

private:
	size_t num;			//랜덤인트
	std::string name;	//[3, 60)까지의 랜덤 소문자로만 구성

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

};

int main() {
	std::ofstream out{ "Dog 10만마리" };
	for (int i = 0; i < 100'000; ++i) {
		Dog dog;
		out << dog << std::endl;
	}


	save("main.cpp");
}