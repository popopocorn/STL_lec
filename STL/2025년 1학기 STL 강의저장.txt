

==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>



// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>



// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록

	auto now = std::chrono::system_clock::now();		//epoch로부터 경과된 tick 수
	std::cout << "현재시간 - " << now << '\n';

	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	using namespace std::chrono_literals;
	auto now = std::chrono::system_clock::now();		//epoch로부터 경과된 tick 수
	std::cout << "현재시간 - " << now + 9h << '\n';

	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t( now );	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경
	
	std::cout << "현재시간 - " << std::put_time(lt, "%c, %A") << "\n";

	out.imbue(old);											//복구
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << '\n';
	out << "==============================================================================================================================\n\n";

	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 2025-03-10 오후 7:03:28, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t( now );	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << std::put_time(lt, "%c, %A") << '\n';
	out << "==============================================================================================================================\n\n";
	out.imbue(old);											//복구
	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 2025-03-10 오후 7:03:46, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<algorithm>
#include<filesystem>
#include<chrono>


// [문제] main을 고치지 말고 실행되게 하라 

void save(std::string_view); // const std::string&의 대체품, 쓰기 불가 읽기만 가능한 객체 

int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if ( not in ) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t( now );	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경
	
	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << std::put_time(lt, "%c, %A") << '\n';
	out << "==============================================================================================================================\n\n";
	out.imbue(old);											//복구
	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}



==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:37:46, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 실행되게 하라 



int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");

}




==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:39:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// save 기능
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 실행되게 하라 



int main() {
	std::cout << "2025년 1학기 STL" << '\n';//살짝 더 빠름 근데 dos창 안쓰잖아

	save("main.cpp");
	save("save.h");
	save("save.cpp");
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:39:09, 목요일
==============================================================================================================================

#pragma once
//-------------------------------------------------------------------
// save.h
//										         		   2025.03.13
//-------------------------------------------------------------------

void save(std::string_view);

==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:39:09, 목요일
==============================================================================================================================

//-------------------------------------------------------------------
// save.cpp - 한학기 강의를 저장
//														   2025.03.13
//-------------------------------------------------------------------


#include<string_view>
#include<fstream>
#include<iostream>
#include<filesystem>
#include<chrono>
#include "save.h"

void save(std::string_view file_name) {
	//1.인자로 전달된 file_name을 읽기 모드로 열기
	std::ifstream in{ file_name.data() };	//RAII, 자원획득시 초기화
	if (not in) {
		std::cout << "Failed to read " << file_name << std::endl;
		// exit(404); 요즘 사용X
	}
	in >> std::noskipws;

	// 저장했다는 것을 화면에 표시하자
	std::cout << file_name << "(" << std::filesystem::file_size(file_name)
		<< "bytes) 저장하였습니다.\n";


	//2.쓰기 모드로 저장할 파일을 덧붙이기 모드로 열기
	std::ofstream out{ "2025년 1학기 STL 강의저장.txt", std::ios::app }; // {}uniform initializer
	//시간을 기록
	auto now = std::chrono::system_clock::now();			//epoch로부터 경과된 tick 수
	auto utc = std::chrono::system_clock::to_time_t(now);	//UTC로 변환
	auto lt = std::localtime(&utc);							//os의 지역시간으로 변경
	auto old = out.imbue(std::locale("ko_KR"));				//stream의 지역을 변경

	out << "\n" << "\n";
	out << "==============================================================================================================================\n";
	out << "저장한 시간: " << std::put_time(lt, "%c, %A") << '\n';
	out << "==============================================================================================================================\n\n";
	out.imbue(old);											//복구
	//3.쓸 파일을 읽어서 저장할 파일에 덧붙인다.
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator(out));
}


==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:53:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 

void change(int& x, int& y);


int main() {

	int a{ 1 }, b{ 2 };
	change(a, b); //ab바꾸기

	std::cout << a << ", " << b << std::endl;

	save("main.cpp");

}

void change(int& x, int& y) {
	int temp = x;
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 5:53:26, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 

void change(int& x, int& y);


int main() {

	int a{ 1 }, b{ 2 };
	change(a, b); //ab바꾸기

	std::cout << a << ", " << b << std::endl;

	save("main.cpp");

}

void change(int& x, int& y) {
	int temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:05:31, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog();
	Dog(int n) {
		age = n;
	}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:06:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Templete
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog();
	Dog(int n) {
		age = n;
	}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:15:52, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Template
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog(int n) : age{ n } {}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:16:31, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Template
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog() = default;
	Dog(int n) : age{ n } {}
	friend std::ostream& operator<<(std::ostream& os, Dog d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}

==============================================================================================================================
저장한 시간: 2025-03-13 오후 6:25:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// Generic Programming - 핵심키워드 Template
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"


// [문제] main을 고치지 말고 의도대로 실행되게 하라 
template<typename t>
void change(t& x, t& y);
class Dog {
public:
	Dog() = default;
	Dog(int n) : age{ n } {}
	friend std::ostream& operator<<(std::ostream& os, const Dog& d) {
		return os << d.age;
	}
private:
	int age;
};

int main() {

	{
		Dog a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b); //ab바꾸기

		std::cout << a << ", " << b << std::endl;
	}

	save("main.cpp");

}
template<typename t>
void change(t& x, t& y) {
	t temp{ x };
	x = y;
	y = temp;
}


==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:39:03, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

//[문제] random한 int 1000개를 화면에 출력하라


int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << rand() << '\n';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:44:10, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid;

int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << uid(dre) << '\n';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:45:42, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << uid(dre) << '\n';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:46:12, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::cout << uid(dre) << ' ';
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:48:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:10}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:49:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:<10}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:50:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 99'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:^10}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 5:51:40, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>

//[문제] random한 int 1000개를 화면에 출력하라
std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);

int main() {
	for (int i = 0; i < 1000;++i) {
		std::print("{:8}", uid(dre));
	}
	
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:04:03, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중ㅇ 가장 큰 값을 찾아 출력하라
int main() {
	int arr[1000];
	int maximum = std::numeric_limits<int>::min();
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		if (arr[i] > maximum) {
			maximum = arr[i];
		}
	}
	std::cout << maximum;
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:04:58, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<print>
#include<array>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중ㅇ 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum = std::numeric_limits<int>::min();
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		if (arr[i] > maximum) {
			maximum = arr[i];
		}
	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:13:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
	}
	int maximum = arr.max_size();
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:14:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre;
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		
	}
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:18:15, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ std::random_device{}() };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		
	}
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:25:31, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) {
		arr[i] = uid(dre);
		
	}
	
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:25:36, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int i = 0; i < 1000;++i) { // 1000- magic number, hard-wired coding
		arr[i] = uid(dre);
		
	}
	
	for (int i = 0; i < 1000; ++i) {
		if (maximum < arr[i])
			maximum = arr[i];

	}
	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:30:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	for (int num : arr) {
		if (maximum < num)
			maximum = num;
	}

	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:40:14, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	int maximum{ std::numeric_limits<int>::min() };
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	std::max_element(arr.begin(), arr.end());

	for (int num : arr) {
		std::print("{:8}", num);
	}

	std::cout << maximum << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:42:42, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	auto pos = std::max_element(arr.begin(), arr.end());

	for (int num : arr) {
		std::print("{:8}", num);
	}

	std::cout << *pos << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:43:32, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;
	for (int& num : arr) {
		num = uid(dre);
		
	}
	
	auto pos = std::max_element(arr.begin(), arr.end());

	for (int num : arr) {
		std::print("{:8}", num);
	}

	std::cout << *pos << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:45:16, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 메모리에 저장하라
//저장한 값 중 가장 큰 값을 찾아 출력하라
int main() {
	std::array<int, 1000> arr;

	for (int& num : arr) 
		num = uid(dre);
		
	std::cout << *std::max_element(arr.begin(), arr.end()) << '\n';
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:47:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<algorithm>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {
	std::array<int, 1000> arr;

	for (int& num : arr) 
		num = uid(dre);
	std::ofstream out{ "int 1000개.txt" };

	for (int num : arr)
		out << num << " ";

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:53:16, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };

	for (int i =0; i<1000;++i)
		out << uid(dre) << " ";

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:56:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };

	for (int i =0; i<1000;++i)
		out << uid(dre) << " --- ";//---는 구분자(딜리미터)

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:57:26, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };

	for (int i = 0; i < 1000; ++i)
		std::print(out, "{:80}", uid(dre));

	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:58:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };
	int counter{};
	for (int i = 0; i < 1000; ++i) {
		std::print(out, "{:80}", uid(dre));
		if (0 == ++counter & 10) {
			out << "\n";
		}
	}
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-17 오후 6:59:06, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 3.10 월요일	(1주차 2일)
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<random>
#include<array>
#include<print>
#include<fstream>


std::mt19937_64 dre{ };
std::uniform_int_distribution uid(0, 9'999'999);


//[문제]랜덤값 1000개를 파일 "int 1000개.txt" 에 저장하라
//저장한 파일은 사람이 읽을 수 있어야 한다.
//나중에 파일에서 int값을 읽어올 수 있어야 한다.
int main() {

	std::ofstream out{ "int 1000개.txt" };
	int counter{};
	for (int i = 0; i < 1000; ++i) {
		std::print(out, "{:80}", uid(dre));
		if (0 == (++counter & 10)) {
			out << "\n";
		}
	}
	save("main.cpp");

}



==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:28:36, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	std::ifstream in{ "int 1000개.txt" };
	if (not in) {
		std::cout << "파일을 찾지 못했습니다.\n";
	}
	int num;
	int max_int = std::numeric_limits<int>::min();

	while (in >> num) {
		if (num > max_int)
			max_int = num;
	}
	std::cout << max_int;

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:29:56, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	
	int num{ 0x01020304 };

	std::cout << "2진수 - " << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - " << std::endl;


	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:30:31, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	
	int num{ 0x01020304 };

	std::cout << "2진수 - " << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - " << std::hex << num << std::endl;


	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:33:51, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int -> Dog
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<bitset>

// [문제] "int 1000개.txt"파일에서 가장  큰 값을 찾아 화면에 출력하라
//출력된 값도 답지에 적어라
int main() {
	
	int num{ 0x01020304 };
	std::bitset<32> binary =  num ;
	std::cout << "2진수 - 0b" << binary << std::endl;
	std::cout << "10진수 - " << num << std::endl;
	std::cout << "16진수 - 0x" << std::hex << num << std::endl;
	ㅌ

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:51:27, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	for (int i = 0; i < a.size(); ++i) {
		a[i] = i + 1;
	}

	for (int num : a) {
		std::cout << num << " ";

	}
	std::cout << "\n";
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 5:54:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	std::iota(a.begin(), a.end(), 1);
	for (int num : a) {
		std::cout << num << ' ';
	}
	std::cout << "\n";
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:07:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:08:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 2000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:09:18, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 10000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:10:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(0);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:12:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(10);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:12:53, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(0x0a0a0a0a);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt" };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:22:56, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"

#include<fstream>
#include<array>
#include<numeric>


// [문제] "int 1000개를 메모리 크기 그대로 저장하고 싶다
// file "int 10000개.txt"fmf apahfl zmeofh . .txt에 저장한다.
// 해당 stream의 저수죽 입출력 함수(read/write)를 사용

int main() {
	std::array<int, 1000> a;
	a.fill(0x0a0a0a0a);
	//std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 1000개를 메모리 그대로.txt", std::ios::binary };
	out.write((char*)a.data(), a.size() * sizeof(int));

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:30:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<random>
//----------------------------------------------------------------------------
// 진짜 랜덤값(non deterministic variable)을 갖는 int 10만개를
// 파일 "진짜 랜덤 10만개"에 저장하였다.
// 파일은 binary모드로 열었고, stream에 write함수를 사용하여 메모리 그대로 저장하였다.


int main() {
	std::random_device rd;

	std::ofstream out{"진짜 랜덤 10만개", std::ios::binary};

	for (int i = 0; i < 100'000; ++i) {
		int num = rd();
		out.write((char*) & num, sizeof(int));

	}

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:52:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}
	int num;
	int cnt{};
	while (in.read((char*)&num, sizeof(int))) {
		++cnt;
	}
	std::cout << cnt << std::endl;
	int max_num = std::numeric_limits<int>::min();
	int min_num = std::numeric_limits<int>::max();
	std::array<int, 100'000> a;
	in.read((char*)a.data(), a.size());
	for (int num : a) {
		if (max_num < num) {
			max_num = num;
		}
		if (min_num > num) {
			min_num = num;
		}
	}

	std::cout << "최대값: " << max_num << std::endl;
	std::cout << "최소값: " << min_num << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:55:22, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최대값: " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "최소값: " << *std::min_element(a.begin(), a.end()) << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:56:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최댓값: " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "최솟값: " << *std::min_element(a.begin(), a.end()) << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-20 오후 6:57:16, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());

	std::cout << "최댓값: " << *std::max_element(a.begin(), a.end()) << std::endl;
	std::cout << "최솟값: " << *std::min_element(a.begin(), a.end()) << std::endl;
	save("main.cpp");
	
}



==============================================================================================================================
저장한 시간: 2025-03-24 오후 5:20:33, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - int를 메모리 크기 그대로 저장하거
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------


// [문제] 진짜 랜덤 10만개에는 int값이 기록되어 있다
// 파일은 binary mode로 열었고, 파일의 write함수로 메모리 그대로 기록하였다.
// 파일에 있는 모든 int값을 메모리에 저장하여라
// 가장 작은 값과 가장 큰값을 찾아 화면에 출력하라


int main() {
	std::ifstream in { "진짜 랜덤 10만개", std::ios::binary };
	if (not in) {
		std::cout << "파일을 열 수 없습니다.\n";

	}

	std::array<int, 100'000> a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	auto minmax = std::minmax_element(a.begin(), a.end());

	std::cout << "최댓값: " << *minmax.second<< std::endl;
	std::cout << "최솟값: " << *minmax.first << std::endl;
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:00:50, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

// Dog객체 10만개를 파일 Dog 10만마리에 저장하였다
//

class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};
int main() {

	Dog dog;
	dog.show();

	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:05:11, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };

// Dog객체 10만개를 파일 Dog 10만마리에 저장하였다
//

class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};
int main() {

	for (int i = 0; i < 100; ++i) {
		Dog dog;
		dog.show();
	}

	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:10:14, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };



class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};

// Dog객체 10만개를 파일 "Dog 10만마리"에 저장하였다
// 파일은 binary mode로 열었고, Dog객체는 file.write함수를 사용하여 저장하였다.
//

int main() {
	std::ofstream out{ "Dog 10만 마리", std::ios::binary };
	for (int i = 0; i < 100'000; ++i) {
		Dog dog;
		out.write((char*) & dog, sizeof(dog));
	}
	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:11:25, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<random>
#include<print>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution<int> uid{ 'a', 'z' };



class Dog {
public:
	Dog() : id{ ++sid } {
		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}

	}
	void show() {
		std::println("[{:8}] - {}", id, name);
	}
	static int sid;	//scope:local, lifetime - global;
private:
	std::string name; // 15글자의 랜덤 소문자로 구성
	int id; // 생성될 때 마다 고유번호 부여
};

int Dog::sid{};

// Dog객체 10만개를 파일 "Dog 10만마리"에 저장하였다
// 파일은 binary mode로 열었고, Dog객체는 file.write함수를 사용하여 저장하였다.
//

int main() {
	std::ofstream out{ "Dog 10만 마리", std::ios::binary };
	for (int i = 0; i < 100'000; ++i) {
		Dog dog;
		out.write((char*) & dog, sizeof(dog));
	}
	
	save("main.cpp");
	
}



==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:34:00, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 제일 마지막 객첼f cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};
std::array < Dog, 100'000> dogs;
int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());
	std::cout << dogs[dogs.size()-1];
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:37:13, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 제일 마지막 객첼f cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());
	std::cout << dogs[dogs.size()-1];
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:39:18, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 제일 마지막 객첼f cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());
	std::cout << dogs.back();
	save("main.cpp");
	
}



==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:44:23, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// Dog객체 10만개를 메모리에 모두 저장하라
// 모든 객체를 화면에 cout으로 출력하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());

	for (const Dog& d : dogs) {
		std::cout << d << std::endl;
	}
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-24 오후 6:58:16, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// 많은 수의 자료 다루기 - Dog를 읽고 쓸 수 있기
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<array>
//----------------------------------------------------------------------------


// 파일 Dog 10만 마리에는 Dog객체 10만개가 저장되어 있다
// 파일은 binary모드로 열었고, Dog 객체는 파일의 write 함수를 사용하여 메모리에 저장하였다.
// 메인코드가 수정없이 실행 될 수 있도록 필요한 코딩을 추가하라

class Dog {
public:
	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		os << "id - " << dog.id << ", name: " << dog.name << std::endl;
		return os;
	}
	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		
		return is.read((char*)&dog, sizeof(dog));
	}
private:
	std::string name;
	int id;
};

std::array < Dog, 100'000> dogs;

int main() {
	
	std::ifstream in{ "Dog 10만 마리", std::ios::binary };
	if (not in) {
		std::cout << "파일을 읽지 못했습니다\n";
		return 20250324;
	}

	for (int i = 0; i < dogs.size(); ++i) {
		in >> dogs[i];
	}

	//출력
	for (const Dog& dog : dogs) {
		std::cout << dog;
	}

	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:51:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:52:36, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:52:44, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 5:54:48, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	

	while (true) {
		int num{};
		int acc{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		while (getchar() != '\n');
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		for (int i = 0; i < num; ++i) {
			acc += a[i];
		}

		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:09:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<numeric>
//----------------------------------------------------------------------------

// [문제] 양의 정수(int의 max값 까지)를 입력 받아 num에 저장하라
// int값을 num개 저장 할 수 있는 메모리를 확보하라
// 메모리의 내용을 1부터 시작하는 정수로 채워라
// 메모리에 있는 값의 합게를 화면에 출력하라
// 이 과정을 영원히 반복하라
//

int main() {

	save("main.cpp");
	
	

	while (true) {
		int num{};
		std::cout << "양의 정수를 입력하시오: \n";
		std::cin >> num;
		while (getchar() != '\n');
		if (num < 1 || num>std::numeric_limits<int>::max()) {
			if (num == 0)
				return 2020202;
			std::cout << "잘못된 입력입니다. \n";
			continue;
		}
		int* a = new int[num];
		std::iota(a, a+num, 1);
		long long acc = std::accumulate(a, a + num, 0);
		
		std::cout << "1부터 " << num << "까지의 합계: " << acc << std::endl;
		delete[] a;
	}
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:15:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[5];
	std::cout << "address - " << p << "---->";
	for (int i = 0; i < 5; ++i) {
		std:: cout << p[i] << " 0";

	}
	std::cout << std::endl;
}
int main() {

	f();

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:15:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[5];
	std::cout << "address - " << p << "---->";
	for (int i = 0; i < 5; ++i) {
		std:: cout << p[i] << " ";

	}
	std::cout << std::endl;
}
int main() {

	f();

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:16:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[5];
	std::cout << "address - " << p << "---->";
	for (int i = 0; i < 5; ++i) {
		std:: cout << p[i] << " ";

	}
	std::cout << std::endl;
	delete[] p;
}
int main() {
	for (int i = 0; i < 10; ++i)
		f();

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:25:14, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------


void f() {
	int* p = new int[200'000'000];


}
int main() {
	try{
		while (true) {
			f();
		}
	}
	catch(const std::exception& e){
		std::cout << e.what() << std::endl;
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:37:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
private:
};

void f() {
	Dog dog;

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:39:48, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
private:
};

void f() {
	Dog* p = new Dog;

	throw 20250327;

	delete p;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:45:39, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

class 스마트 {
public:
	스마트(Dog* p) : p{ p } {}
	~스마트() {
		delete p;
	}
private:
	Dog* p;
};



void f() {
	스마트 p{ new Dog };

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:53:06, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog> p{ new Dog };

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:53:42, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog[]> p{new Dog[10]};

	throw 20250327;
}
int main() {
	
	try{
		f();
	}
	catch (...) {
		std::cout << "예외를 catch하였다.\n";
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:54:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog[]> p{new Dog[10]};
	std::cout << "끝난다\n";
}
int main() {
	f();
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-27 오후 6:56:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// RAII와 smart pointer
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<memory>
//----------------------------------------------------------------------------

class Dog {
public:
	Dog() {
		std::cout << "생성\n";
	}
	~Dog() {
		std::cout << "소멸\n";
	}
};

void f() {
	std::unique_ptr<Dog[]> p = std::make_unique<Dog[]>(10);
	std::cout << "끝난다\n";
}
int main() {
	f();
	save("main.cpp");
	
	
}



==============================================================================================================================
저장한 시간: 2025-03-31 오후 5:35:45, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
//----------------------------------------------------------------------------

// [문제] main.cpp파일을 소문자를 대문자로 전부 변환하여 "main 대문자.cpp"에 저장하라
//
int main() {
	std::ifstream in{ "main.cpp" };
	if (not in) {
		return 02020202;
	}
	std::ofstream out{ "main 대문자.cpp" };
	char c;
	in >> std::noskipws;
	
	while (in >> c) {
		if (islower(c)) 
			c = toupper(c);
		out << c;
		
	}

	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 5:51:17, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

// [문제] main.cpp파일을 소문자를 대문자로 전부 변환하여 "main 대문자.cpp"에 저장하라
//
int main() {
	std::ifstream in{ "main.cpp" };
	if (not in) {
		return 02020202;
	}
	std::ofstream out{ "main 대문자.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {},
		std::ostreambuf_iterator<char>{std::cout}, [](char c) {
			return toupper(c);
		});

	save("main.cpp");
	
	
}



==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:12:53, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;
int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	
	qsort(arr.data(),arr.size(), sizeof(int), 
		[](const void* a, const void* b) {
			return *(int*)a - *(int*)b;
		});
	for (int i = 0; i < 1000; ++i) {
		std::print("{:8}", arr[i]);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:18:24, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;
int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	
	qsort(arr.data(),arr.size(), sizeof(int), 
		[](const void* a, const void* b) {
			return *(int*)a - *(int*)b;
		});
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:35:00, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include "main.h"
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int 오름차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x < y)
		return -1;
	else if(x > y)
		return 1;
	return 0;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	qsort(arr.data(), arr.size(), sizeof(std::array<int, 10'000'000>::value_type),
		//[](const void* a, const void* b) {
		//	return *(int*)a - *(int*)b; // 오름차순
		//	//return *(int*)b - *(int*)a; //내림차순
		//}
		오름차순
	);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:51:27, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int 오름차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x < y)
		return -1;
	else if(x > y)
		return 1;
	return 0;
}
int 내림차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x > y)
		return -1;
	else if (x < y)
		return 1;
	return 0;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	int(*정렬방법)(const void*, const void*) = (int(*)(const void*, const void*))오름차순;

	qsort(arr.data(), arr.size(), sizeof(int), 정렬방법);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:51:40, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int 오름차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x < y)
		return -1;
	else if(x > y)
		return 1;
	return 0;
}
int 내림차순(const void* a, const void* b) {

	int x = *(int*)a;
	int y = *(int*)b;
	if (x > y)
		return -1;
	else if (x < y)
		return 1;
	return 0;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	int(*정렬방법)(const void*, const void*) = (int(*)(const void*, const void*))내림차순;

	qsort(arr.data(), arr.size(), sizeof(int), 정렬방법);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
	
	
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 6:53:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;


int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	sort(arr.begin(), arr.end());
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 7:02:30, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬
	sort(arr.begin(), arr.end(), 내림차순);
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-03-31 오후 7:04:54, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "정렬시간: " << e - b << std::endl;
	
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 5:34:46, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	auto b = std::chrono::high_resolution_clock::now();
	std::sort(arr.begin(), arr.end());					//default는 오른차순
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "정렬시간: " << e - b << std::endl;
	std::cout << "정렬시간(ms): " << std::chrono::duration_cast<std::chrono::milliseconds > (e - b) << std::endl;
	
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-04-03 오후 5:46:00, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "내림차순 정렬시간    : " << e - b << std::endl;

	{
		for (int& i : arr) {
			i = uid(dre);
		}
		//sort로 내림차순 정렬 
		//아마 대부분 lambda로 코딩할거임
		auto b = std::chrono::high_resolution_clock::now();
		sort(arr.begin(), arr.end(), [](int a, int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "내림차순 정렬시간(람다): " << e - b << std::endl;
		

	}
	for (int num : arr | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:06:08, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "내림차순 정렬시간        : " << e - b << std::endl;

	{
		for (int& i : arr) {
			i = uid(dre);
		}
		//sort로 내림차순 정렬 
		//아마 대부분 lambda로 코딩할거임
		auto b = std::chrono::high_resolution_clock::now();
		sort(arr.begin(), arr.end(), [](int a, int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "내림차순 정렬시간(람다): " << e - b << std::endl;
		

	}
	for (int num : arr | std::views::take(10000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:08:40, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<random>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid{ 0, 9'999'999 };


// [문제] 랜덤 int값[ 0, 10'000'000 ) 1000만개를 저장할 메모리를 확보하고, 값을 채워라
// 시작 - qsort로 오름차순 정렬하라
// 정렬 결과 중, 앞에서 1000개만 출력하라
// 

std::array<int, 10'000'000> arr;

bool 내림차순(int a, int b) { // const를 붙여도 안붙여도 상관 없다
	return a > b;
}

int main() {
	for (int& i : arr) {
		i = uid(dre);
	}
	//sort로 내림차순 정렬 
	//시간을 보자
	auto b = std::chrono::high_resolution_clock::now();
	sort(arr.begin(), arr.end(), 내림차순);
	auto e = std::chrono::high_resolution_clock::now();

	std::cout << "내림차순 정렬시간      : " << e - b << std::endl;

	{
		for (int& i : arr) {
			i = uid(dre);
		}
		//sort로 내림차순 정렬 
		//아마 대부분 lambda로 코딩할거임
		auto b = std::chrono::high_resolution_clock::now();
		sort(arr.begin(), arr.end(), [](int a, int b) {
			return a > b;
			});
		auto e = std::chrono::high_resolution_clock::now();

		std::cout << "내림차순 정렬시간(람다): " << e - b << std::endl;
		

	}
	for (int num : arr | std::views::reverse | std::views::take(1000)) {
		std::print("{:8}", num);
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:13:16, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	
	std::cout << "lambda의 정체" << typeid([]() {}).name() << std::endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:22:37, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면
	class 람다 {
	public:
		void operator()(){
			std::cout << "나는 람다야" << std::endl;
		};
	};
	//로 변환한다
	람다 f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:23:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면
	class 람다 {
	public:
		void operator()(){
			std::cout << "나는 람다야" << std::endl;
		};
	};
	//로 변환한다
	람다 f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:23:49, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면
	class XYZ {
	public:
		void operator()(){
			std::cout << "나는 람다야" << std::endl;
		};
	};
	//로 변환한다
	XYZ f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:24:25, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class XYZ {
public:
	void operator()() {
		std::cout << "나는 람다야" << std::endl;
	};
};

int main() {
	//[](){std::cout << "나는 람다야" << std::endl;};를 만나게 되면

	//로 변환한다
	XYZ f;
	
	f();

	std::cout << "람다의 정체" << typeid(f).name() << std::endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:29:05, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	Dog dog;

	dog(1);//이것도 오버로딩 가능 operator() - function call operator

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:34:21, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수
// 2.함수포인터
// 3.람다 - 이름없는 함수인데, vs에서는 함수 객체를 이용하여 람다를 구현
// 4.함수객체(function object) - 함수호출 연산자를 오버로딩한 클래스의 객체
// 5.멤버함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	int a;
	int b;

	a = b;			//두 변수의 타입이 같다면 이 문장은 항상 참이다

	Dog dog;

	dog(1);			//이것도 오버로딩 가능 operator() - function call operator

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:43:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입
// 1.함수 - 함수
// 2.함수포인터 - 함수
// 3.람다 - 이름없는 함수인데, vs에서는 함수 객체를 이용하여 람다를 구현
// 4.함수객체(function object) - 함수호출 연산자를 오버로딩한 클래스의 객체
// 5.멤버함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	//void a(int);
	//void b(int);

	//void(*f)(int) = a;
	//f = b;
	////f가 a, b 모두 담을 수 있다면 a는 b와 같은 형식?


	Dog dog;

	dog(1);			//이것도 오버로딩 가능 operator() - function call operator

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:47:22, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
// 1.함수 - 함수
// 2.함수포인터 - 함수
// 3.람다 - 이름없는 함수인데, vs에서는 함수 객체를 이용하여 람다를 구현
// 4.함수객체(function object) - 함수호출 연산자를 오버로딩한 클래스의 객체
// 5.멤버함수
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<functional>
//----------------------------------------------------------------------------

class Dog {
public:
	void operator()(int n) const {
		std::cout << "왜불러\n";
	}
};

int main() {
	//std::sort(b, e, std::function<int(int, int)> f); //실제론 이렇게 하진 않음


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:51:04, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------

class Dog {
public:
	bool operator()(int a, int b) const {
		return a < b;
	}
};

// [문제] 오름차순으로 정렬되게 하라
int main() {
	
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	Dog dog;

	std::sort(a.begin(), a.end(), dog);

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 6:52:13, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------

class Dog {
public:
	bool operator()(int a, int b) const {
		return a < b;
	}
};

// [문제] 오름차순으로 정렬되게 하라
int main() {
	
	std::array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	Dog dog;

	std::sort(a.begin(), a.end(), dog);
	
	for (int num : a)
		std::cout << num;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 7:01:27, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<random>
#include<fstream>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid;
std::uniform_int_distribution uidLen{ 3, 59 };
std::uniform_int_distribution<int> uidName{ 'a', 'z'};

// [과제] Dog객체 10만개를 파일 Dog 10만마리에 저장한다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
// 로 저장하였다
//

class Dog {
public:
	Dog() {
		num = uid(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	};

private:
	size_t num;			//랜덤인트
	std::string name;	//[3, 60)까지의 랜덤 소문자로만 구성

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

};

int main() {
	for (int i = 0; i < 10; ++i) {
		Dog dog;
		std::cout << dog << std::endl;
	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-03 오후 7:02:49, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<random>
#include<fstream>
//----------------------------------------------------------------------------
std::default_random_engine dre;
std::uniform_int_distribution uid;
std::uniform_int_distribution uidLen{ 3, 59 };
std::uniform_int_distribution<int> uidName{ 'a', 'z'};

// [과제] Dog객체 10만개를 파일 Dog 10만마리에 저장한다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
// 로 저장하였다
//

class Dog {
public:
	Dog() {
		num = uid(dre);
		int len = uidLen(dre);
		for (int i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	};

private:
	size_t num;			//랜덤인트
	std::string name;	//[3, 60)까지의 랜덤 소문자로만 구성

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

};

int main() {
	std::ofstream out{ "Dog 10만마리" };
	for (int i = 0; i < 100'000; ++i) {
		Dog dog;
		out << dog << std::endl;
	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-07 오후 5:33:36, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<ranges>
//----------------------------------------------------------------------------


// [과제]  eclass에서 받은 파일 Dog 10만마리에는
// class Dog 객체가 정확하게 10만개가 저장되어있다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
//

class Dog {
private:
	size_t num;			
	std::string name;	

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}

};
// [문제] 파일에 저장ㄷ된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라
// 마지막 객체의 정보를 화면에 출력하고, 출력된 내용을 답지에도 적어라
// 메모리에 있는 Dog객체를 name의 길이기준 오름차순으로 정렬하라
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적는다
// 
std::array<Dog, 100'000> dogs;

int main() {
	std::ifstream in{ "Dog 10만마리" };

	if (not in) {
		std::cout<<"failed to open\n";
	}

	int cnt = 0;

	while (in >> dogs[cnt]) {
		++cnt;
	}
	std::cout << dogs[dogs.size() - 1] << std::endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-07 오후 5:44:26, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<ranges>
#include<print>
//----------------------------------------------------------------------------


// [과제]  eclass에서 받은 파일 Dog 10만마리에는
// class Dog 객체가 정확하게 10만개가 저장되어있다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
//

class Dog {
public:
	void show() {
		std::println("{:12} - {}",num,name);
	}
private:
	size_t num;			
	std::string name;	

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};
// [문제] 파일에 저장ㄷ된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라
// 마지막 객체의 정보를 화면에 출력하고, 출력된 내용을 답지에도 적어라
// 메모리에 있는 Dog객체를 name의 길이기준 오름차순으로 정렬하라
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적는다
// 
std::array<Dog, 100'000> dogs;

int main() {
	std::ifstream in{ "Dog 10만마리" };

	if (not in) {
		std::cout<<"failed to open\n";
	}

	int cnt = 0;

	while (in >> dogs[cnt]) {
		++cnt;
	}
	//std::cout << dogs[dogs.size() - 1] << std::endl;
	dogs[dogs.size() - 1].show();
	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-04-07 오후 5:45:58, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<ranges>
#include<print>
//----------------------------------------------------------------------------


// [과제]  eclass에서 받은 파일 Dog 10만마리에는
// class Dog 객체가 정확하게 10만개가 저장되어있다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
//

class Dog {
public:
	void show() {
		std::println("{:12} - {}",num,name);
	}
private:
	size_t num;			
	std::string name;	

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};
// [문제] 파일에 저장ㄷ된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라
// 마지막 객체의 정보를 화면에 출력하고, 출력된 내용을 답지에도 적어라
// 메모리에 있는 Dog객체를 name의 길이기준 오름차순으로 정렬하라
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적는다
// 
std::array<Dog, 100'000> dogs;

int main() {
	std::ifstream in{ "Dog 10만마리" };

	if (not in) {
		std::cout<<"failed to open\n";
	}

	int cnt = 0;

	while (in >> dogs[cnt]) {
		++cnt;
	}
	//std::cout << dogs.back() << std::endl;
	dogs.back().show();
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-07 오후 5:58:54, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<ranges>
#include<print>
#include<algorithm>
//----------------------------------------------------------------------------


// [과제]  eclass에서 받은 파일 Dog 10만마리에는
// class Dog 객체가 정확하게 10만개가 저장되어있다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
//

class Dog {
public:
	
	std::string getName() const {
		return name;
	}
	
	void show() {
		std::println("{:12} - {}",num,name);
	}
	
private:
	size_t num;			
	std::string name;	

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};
// [문제] 파일에 저장ㄷ된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라
// 마지막 객체의 정보를 화면에 출력하고, 출력된 내용을 답지에도 적어라
// 메모리에 있는 Dog객체를 name의 길이기준 오름차순으로 정렬하라
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적는다
// 
std::array<Dog, 100'000> dogs;

int main() {
	std::ifstream in{ "Dog 10만마리" };

	if (not in) {
		std::cout<<"failed to open\n";
	}

	int cnt = 0;

	while (in >> dogs[cnt]) {
		++cnt;
	}
	//std::cout << dogs.back() << std::endl;
	dogs.back().show();
	
	std::cout << "name의 길이기준 오름차순 정렬\n";
	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getName().size() < b.getName().size(); // 보통은 size 얘만 length도 가능
		});
	dogs.back().show();
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-07 오후 6:01:50, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<ranges>
#include<print>
#include<algorithm>
//----------------------------------------------------------------------------


// [과제]  eclass에서 받은 파일 Dog 10만마리에는
// class Dog 객체가 정확하게 10만개가 저장되어있다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
//

class Dog {
public:
	
	std::string getName() const {
		return name;
	}
	
	void show() const {
		std::println("{:12} - {}",num,name);
	}
	
private:
	size_t num;			
	std::string name;	

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}
};
// [문제] 파일에 저장ㄷ된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라
// 마지막 객체의 정보를 화면에 출력하고, 출력된 내용을 답지에도 적어라
// 메모리에 있는 Dog객체를 name의 길이기준 오름차순으로 정렬하라
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적는다
// 
std::array<Dog, 100'000> dogs;

int main() {
	std::ifstream in{ "Dog 10만마리" };

	if (not in) {
		std::cout<<"failed to open\n";
	}

	int cnt = 0;

	while (in >> dogs[cnt]) {
		++cnt;
	}
	//std::cout << dogs.back() << std::endl;
	dogs.back().show();
	
	std::cout << "name의 길이기준 오름차순 정렬\n";
	std::sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getName().size() < b.getName().size(); // 보통은 size 얘만 length도 가능
		});
	for (const Dog& dog : dogs)
		dog.show();
	dogs.back().show();
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-07 오후 6:05:54, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// Callable - 호출 가능한 타입 -> 모든 호출 가능 타입을 대표하는 function
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<ranges>
#include<print>
#include<algorithm>
//----------------------------------------------------------------------------


// [과제]  eclass에서 받은 파일 Dog 10만마리에는
// class Dog 객체가 정확하게 10만개가 저장되어있다
// 파일은 
//			ofstream out{"Dog 10만마리"};
// Dog 타입의 객체 dog를
//			out << dog;
//

class Dog {
public:
	bool operator<(const Dog& rhs) const {
		return name.length() < rhs.name.length();
	}

	std::string getName() const {
		return name;
	}
	
	void show() const {
		std::println("{:12} - {}",num,name);
	}
	
private:
	size_t num;			
	std::string name;	

	friend std::ostream& operator<<(std::ostream& os, const Dog& dog) {
		return os << dog.num << " " << dog.name << " ";
	}

	friend std::istream& operator>>(std::istream& is, Dog& dog) {
		return is >> dog.num >> dog.name;
	}

};
// [문제] 파일에 저장ㄷ된 10만개의 Dog객체를 모두 읽어 메모리에 저장하라
// 마지막 객체의 정보를 화면에 출력하고, 출력된 내용을 답지에도 적어라
// 메모리에 있는 Dog객체를 name의 길이기준 오름차순으로 정렬하라
// 정렬한 마지막 객체의 정보를 화면에 출력하고 답지에도 적는다
// 
std::array<Dog, 100'000> dogs;

int main() {
	std::ifstream in{ "Dog 10만마리" };

	if (not in) {
		std::cout<<"failed to open\n";
	}

	int cnt = 0;

	while (in >> dogs[cnt]) {
		++cnt;
	}
	//std::cout << dogs.back() << std::endl;
	dogs.back().show();
	
	std::cout << "name의 길이기준 오름차순 정렬\n";
	// sort 에서는 less<>{}를 이용
	// Dog < Dog가 가능하면 문제가 없다(17까지만 가능)
	std::sort(dogs.begin(), dogs.end());

	for (const Dog& dog : dogs)
		dog.show();
	dogs.back().show();
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-07 오후 6:40:22, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - sdt::string 모방
// 1.OOPL - 특정 자료형 만을 위한 코딩 - virtual, polymorphism
// 2.Generic - 자료형과 관계 없는 코딩(함수 - alghrothm
//									   클래스 - 자료구조)
//  ㄴ standard "TEMPLETE" library
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
//----------------------------------------------------------------------------

class STRING {
public:
	STRING(){
	}
private:

};
int main() {

	std::string s{ "std::string을 모방한 클래스" };

	std::cout << "s가 관리하는 바이트 수 - " << s.size() << std::endl;

	std::string t = s;

	std::cout << t<<std::endl;
	std::cout << s<<std::endl;


	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-04-07 오후 7:04:15, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - sdt::string 모방
// 1.OOPL - 특정 자료형 만을 위한 코딩 - virtual, polymorphism
// 2.Generic - 자료형과 관계 없는 코딩(함수 - alghrothm
//									   클래스 - 자료구조)
//  ㄴ standard "TEMPLETE" library
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
//----------------------------------------------------------------------------
#include<string>
#include<memory>
//----------------------------------------------------------------------------

class STRING {
public:
	STRING(const char* c) : len{ strlen(c) } {	//인자에서 t[N] - t*로 collapsing
		str.release();							// 멤버에서 초기화 해두면 할 필요는 없음
		str = std::make_unique<char[]>(len);
		memcpy(str.get(), c, len);					// DMA가 가능한 명령
	}

	size_t size() const {
		return len;
	}
private:
	std::unique_ptr<char[]> str{};
	size_t len{};


	friend std::ostream& operator<<(std::ostream& os, const STRING& s) {
		for (int i = 0; i < s.len; ++i) {
			os << s.str[i];
		}
		return os;
	}

};
int main() {

	STRING s{ "std::string을 모방한 클래스" };

	std::cout << "s가 관리하는 바이트 수 - " << s.size() << std::endl;

	//STRING t = s;

	
	std::cout << s <<std::endl;
	//std::cout << t <<std::endl;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-04-10 오후 6:03:02, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - STL의 표준 컨테이너가 되도록 발전 시킨다
//							벡터의 동작을 진짜 자세히 이해한다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<string>
#include<memory>
//----------------------------------------------------------------------------

int main() {

	STRING s{ "std::string을 모방한 클래스" };

	std::cout << "s가 관리하는 바이트 수 - " << s.size() << std::endl;

	//STRING t = s;

	
	std::cout << s <<std::endl;
	//std::cout << t <<std::endl;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-04-10 오후 6:42:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - STL의 표준 컨테이너가 되도록 발전 시킨다
//							벡터의 동작을 진짜 자세히 이해한다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<string>
#include<memory>
//----------------------------------------------------------------------------

int main() {

	STRING s{ "std::string을 모방한 클래스" };
	

	STRING t;

	STRING u = s;

	
	std::cout << s <<std::endl;
	std::cout << t <<std::endl;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-04-10 오후 7:01:37, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - STL의 표준 컨테이너가 되도록 발전 시킨다
//							벡터의 동작을 진짜 자세히 이해한다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<string>
#include<memory>
//----------------------------------------------------------------------------

int main() {

	STRING t;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-10 오후 7:02:46, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - STL의 표준 컨테이너가 되도록 발전 시킨다
//							벡터의 동작을 진짜 자세히 이해한다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<string>
#include<memory>
//----------------------------------------------------------------------------

int main() {

	STRING t;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-10 오후 7:05:06, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - STL의 표준 컨테이너가 되도록 발전 시킨다
//							벡터의 동작을 진짜 자세히 이해한다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<string>
#include<memory>
//----------------------------------------------------------------------------


//다음시간 관찰 메시지 해석
STRING x{ "수업시간이너무짧아" };

int main() {

	STRING s{ "nanananananan" };

	STRING t;
	STRING u = s;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 5:30:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// class STRING 작성 시작 - STL의 표준 컨테이너가 되도록 발전 시킨다
//							벡터의 동작을 진짜 자세히 이해한다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<string>
#include<fstream>
#include<memory>
#include<array>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	ifstream in{ "main.cpp" };
	if (not in) {
		return 00000125;
	}
	array<STRING, 50> words;
	
	for (STRING& word : words) {
		in >> word;
	}
	sort(words.begin(), words.end());

	for (auto i = words.rbegin(); i != words.rend(); ++i) {
		cout << *i << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 6:40:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	vector<int> v;	//container는 v

	cout << addressof(v) << endl;
	cout << typeid(v).name() << endl;
	cout << sizeof(v) << endl;





	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 6:47:42, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

vector<int> v;	//container는 v

int main() {

	

	cout << addressof(v) << endl;
	cout << typeid(v).name() << endl;
	cout << sizeof(v) << endl;





	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 6:50:19, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	vector<int>* v = new vector<int>;	//container는 v

	cout << addressof(v) << endl;
	cout << typeid(*v).name() << endl;
	cout << sizeof(*v) << endl;





	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 6:59:53, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	vector<int> v;

	cout << v.size() << endl;
	cout << v.capacity() << endl;
	cout << v.data() << endl;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 7:00:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	vector<int> v;

	cout << "원소 개수 - " << v.size() << endl;
	cout << "담을 수 있는 원소 개수 - " << v.capacity() << endl;
	cout << "자원 주수 - " << v.data() << endl;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-17 오후 7:02:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	vector<int> v;

	cout << "원소 개수 - " << v.size() << endl;
	cout << "담을 수 있는 원소 개수 - " << v.capacity() << endl;
	cout << "자원 주수 - " << v.data() << endl;

	cout << endl;
	cout << "원소 한 개 추가 한 후 vector v의 field" << endl;
	v.push_back(1);

	cout << "원소 개수 - " << v.size() << endl;
	cout << "담을 수 있는 원소 개수 - " << v.capacity() << endl;
	cout << "자원 주수 - " << v.data() << endl;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 5:38:00, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 벡터는 어떻게 메모리를 관리하는가.
int main() {
	vector<int>v;
	size_t old = v.capacity();
	for (int i = 0; i < 10000;++i) {
		v.push_back(i);
		
		if (old != v.capacity()) {
			cout << "v가 재할당 하지 않고 원소를 담을 수 있는 개수: " << v.capacity() << endl; // 용량
			old = v.capacity();
		}

	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 6:20:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 벡터는 어떻게 메모리를 관리하는가.
int main() {
	vector<int>v;
	v.reserve(5000);
	size_t old = v.capacity();
	for (int i = 0; i < 10000;++i) {
		v.push_back(i);
		
		if (old != v.capacity()) {
			cout << "v가 재할당 하지 않고 원소를 담을 수 있는 개수: " << v.capacity() << endl; // 용량
			old = v.capacity();
		}

	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 6:29:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 키보드에서 단어를 입력받아 오름차순으로 정렬 후 출력하라
int main() {

	vector<string> v{ istream_iterator<string>{cin},{} };
	sort(v.begin(), v.end());
	for (const string& s : v)
		cout << s << endl;

	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 6:31:26, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
#include<fstream>
//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 키보드에서 단어를 입력받아 오름차순으로 정렬 후 출력하라
int main() {

	ifstream in{ "main.cpp" };

	vector<string> v{ istream_iterator<string>{in},{} };
	sort(v.begin(), v.end());
	for (const string& s : v)
		cout << s << endl;

	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 6:36:11, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>

//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 키보드에서 단어를 입력받아 오름차순으로 정렬 후 출력하라
int main() {
	관찰 = true;
	vector<STRING> v;
	STRING s{"12345"};
	v.push_back(s);
	// -> const STRING s


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 6:45:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>

//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 키보드에서 단어를 입력받아 오름차순으로 정렬 후 출력하라
int main() {
	관찰 = true;
	vector<STRING> v;
	
	v.push_back(STRING { "12345" } );

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-04-21 오후 6:59:59, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
//	STL container - Containers are objects that store other objects.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>

//----------------------------------------------------------------------------

extern bool 관찰;


// [문제] 키보드에서 단어를 입력받아 오름차순으로 정렬 후 출력하라
int main() {
	관찰 = true;
	vector<STRING> v;
	
	v.emplace_back(STRING { "12345" } );
	
	save("main.cpp");
}
------------------------------------------------------------------------------------------------------------------------------
중간고사 끝
------------------------------------------------------------------------------------------------------------------------------
==============================================================================================================================
저장한 시간: 2025-04-28 오후 6:39:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array -
// vector - at
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	int a[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	while (true) {
		cout << "몇 번째를 원하냐: ";
		int num;
		cin >> num;

		cout << "찾는 값은: " << a[num] << endl;
	}

	
}

==============================================================================================================================
저장한 시간: 2025-04-28 오후 6:42:06, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array -
// vector - at
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	array<int, 10> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//vector<int> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	while (true) {
		cout << "몇 번째를 원하냐: ";
		int num;
		cin >> num;

		cout << "찾는 값은: " << a.at(num) << endl;
	}

	
}

==============================================================================================================================
저장한 시간: 2025-04-28 오후 6:42:25, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array -
// vector - at
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	array<int, 10> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//vector<int> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	while (true) {
		cout << "몇 번째를 원하냐: ";
		int num;
		cin >> num;

		cout << "찾는 값은: " << a.at(num) << endl;
	}

	
}

==============================================================================================================================
저장한 시간: 2025-04-28 오후 6:42:52, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array -
// vector - at
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	array<int, 10> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//vector<int> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	while (true) {
		cout << "몇 번째를 원하냐: ";
		int num;
		cin >> num;

		cout << "찾는 값은: " << a[num] << endl;
	}

	
}

==============================================================================================================================
저장한 시간: 2025-04-28 오후 6:45:06, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array -
// vector - at
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	array<int, 10> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//vector<int> a{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	while (true) {
		cout << "몇 번째를 원하냐: ";
		int num;
		cin >> num;
		
		try{
			cout << "찾는 값은: " << a.at(num) << endl;
		}
		catch( ... ){

		}
	}

	
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 5:33:20, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	vector<int> v{ 1, 2, 3, 4, 5 };
	
	//[문제] v에서3을 제거하라
	remove(v.begin(), v.end(), 3);
	
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << " ";
	}
	cout << endl;

	
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 5:56:57, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	vector<int> v{ 1, 2, 3, 4, 5 };
	
	//[문제] v에서3을 제거하라
	//vector<int>::iterator newEnd = remove(v.begin(), v.end(), 3);
	auto newEnd = remove(v.begin(), v.end(), 3);
	v.erase(newEnd, v.end());
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << " ";
	}

	
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:11:20, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	vector<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	erase(v, "333");
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:23:45, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	vector<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	erase(v, "333");
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:27:20, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	save("main.cpp");
	
	vector<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	erase(v, "333");
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:29:28, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	
	vector<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	관찰 = true;
	erase(v, "333");
	관찰 = false;
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:34:09, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	
	list<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	//관찰 = true;
	//erase(v, "333");
	//관찰 = false;
	//for (const STRING& s : v)
	//	cout << s << endl;

	//cout << endl;
	cout << sizeof v << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:41:03, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	
	list<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	관찰 = true;
	erase(v, "333");
	관찰 = false;
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:51:00, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	
	list<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	관찰 = true;
	//v.remove("333"); // 실행되지만 0점
	v.remove("333");
	관찰 = false;
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 6:52:20, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	
	list<STRING> v{ "1", "22", "333", "4444", "55555"};	
	//[ 문제 ] 333을 제거하라
	STRING t{ "333" };
	관찰 = true;
	//v.remove("333"); // 실행되지만 0점
	v.remove(t);
	관찰 = false;
	for (const STRING& s : v)
		cout << s << endl;

	cout << endl;
	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-01 오후 7:01:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, O(1) push_front, push_back
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>

//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	deque<int>d;
	
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 5:45:59, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	vector<int>v;
	cout << "벡터가 저장 가능한 최대 int 수 - " << v.max_size() << endl;


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 5:51:49, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};

int main() {
	{
		vector<Test>v;
		while (true) {
			try{
				v.emplace_back();
			}
			catch (exception& e) {
				cout << e.what() << endl;
				cout << "최대개수 - " << v.size() << endl;
				break;
			}

		}

	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 5:55:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};

int main() {
	//{
	//	vector<Test>v;
	//	//27310
	//	while (true) {
	//		try{
	//			v.emplace_back();
	//		}
	//		catch (exception& e) {
	//			cout << e.what() << endl;
	//			cout << "최대개수 - " << v.size() << endl;
	//			break;
	//		}

	//	}

	//}
	{
		deque<Test>v;
		//27310
		while (true) {
			try {
				v.emplace_back();
			}
			catch (exception& e) {
				cout << e.what() << endl;
				cout << "최대개수 - " << v.size() << endl;
				break;
			}

		}

	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:00:06, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};



int main() {
	{
		list<Test>v;
		//
		while (true) {
			try{
				v.emplace_back();
			}
			catch (exception& e) {
				cout << e.what() << endl;
				cout << "최대개수 - " << v.size() << endl;
				break;
			}

		}

	}
	{
		deque<Test>d;
		//55814
		while (true) {
			try {
				d.emplace_back();
			}
			catch (exception& e) {
				cout << e.what() << endl;
				cout << "최대개수 - " << d.size() << endl;
				break;
			}

		}

	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:08:37, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};



int main() {
	deque<int> d{ 1, 2, 3, 4 };

	for (int i = 0; i < d.size(); ++i) {
		cout << addressof(d[i]) << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:09:58, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};



int main() {
	deque<int> d{ 1, 2, 3, 4 };
	d.push_front(0);
	d.push_front(-1);
	d.push_back(5);
	d.push_back(6);
	for (int i = 0; i < d.size(); ++i) {
		cout << addressof(d[i]) << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:11:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};



int main() {
	deque<int> d{ 1, 2, 3, 4 };
	d.push_front(0);
	d.push_front(-1);
	d.push_back(5);
	d.push_back(6);
	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << "        " << addressof(d[i]) << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:17:24, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<deque>
//----------------------------------------------------------------------------

extern bool 관찰;


class Test {
	char x[1'000'000];
};



int main() {
	deque<int> d{ 1, 2, 3, 4 };
	d.push_front(0);
	d.push_front(-1);
	d.push_back(5);
	d.push_back(6);
	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << "        " << addressof(d[i]) << endl;
	}
	LOP:
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:25:16, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	list<STRING> cont{"1", "22", "4444", "55555"};

	// [문제]333을 추가하라
	관찰 = true;
	cont.insert(++++cont.begin(), STRING{ "333" });
	관찰 = false;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:27:03, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	list<STRING> cont{"1", "22", "4444", "55555"};

	// [문제]333을 추가하라
	관찰 = true;
	cont.emplace(++++cont.begin(), STRING{ "333" });
	관찰 = false;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:27:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<list>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	list<STRING> cont{"1", "22", "4444", "55555"};

	// [문제]333을 추가하라
	관찰 = true;
	cont.emplace(++++cont.begin(), "333" );
	관찰 = false;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:34:28, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라
	list<STRING> mainwords;

	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;
	while (in >> t) {
		
		mainwords.push_back(t);
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:38:57, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라
	list<STRING> mainwords;

	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;
	while (in >> t) {
		mainwords.push_back(t);
	}

	for (const STRING& s : mainwords) {
		cout << s << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:40:57, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> mainwords{ istream_iterator<STRING>{in},{} };
	
	for (const STRING& s : mainwords) {
		cout << s << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:43:55, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> mainwords{ istream_iterator<STRING>{in},{} };
	vector<STRING> v{ mainwords.begin(), mainwords.end()};

	관찰 = true;
	sort(v.begin(), v.end());

	관찰 = false;

	
	for (const STRING& s : v) {
		cout << s << endl;
	}

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:45:24, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> mainwords{ istream_iterator<STRING>{in},{} };
	vector<STRING> v{ mainwords.begin(), mainwords.end()};

	관찰 = true;
	sort(v.begin(), v.begin()+10);

	관찰 = false;

	
	/*for (const STRING& s : v) {
		cout << s << endl;
	}*/

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:45:38, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> mainwords{ istream_iterator<STRING>{in},{} };
	vector<STRING> v{ mainwords.begin(), mainwords.end()};

	관찰 = true;
	sort(v.begin(), v.begin()+5);

	관찰 = false;

	
	/*for (const STRING& s : v) {
		cout << s << endl;
	}*/

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:49:10, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	vector<STRING> v{ words.begin(), words.end()};

	관찰 = true;
	words.sort();
	관찰 = false;

	
	/*for (const STRING& s : v) {
		cout << s << endl;
	}*/

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:50:57, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	vector<STRING> v{ words.begin(), words.end()};

	관찰 = true;
	words.sort();/*
	sort(v.begin(), v.begin() + 5);
	//*/
	관찰 = false;
	
	
	///*
	for (const STRING& s : v) {
		cout << s << endl;
	}
	//*/

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-08 오후 6:51:17, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<vector>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}
	STRING t;

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	vector<STRING> v{ words.begin(), words.end()};

	관찰 = true;
	words.sort();/*
	sort(v.begin(), v.begin() + 5);
	//*/
	관찰 = false;
	
	
	///*
	for (const STRING& s : words) {
		cout << s << endl;
	}
	//*/

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-12 오후 6:50:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {


	save("main.cpp");
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}

	list<STRING> words{ istream_iterator<STRING>{in},{} };


	// [문제] 사용자가 입력한 단어가 리스트에 있는 지 알려주자
	// 단어가 없으면 없다고 출력하고, 있으면 리스트의 몇번 째 단어인지 출력하라.

	while (true)
	{
		STRING w;
		cout << "찾을 단어는: ";
		cin >> w;
		auto finded = find(words.begin(), words.end(), w);
		if (finded == words.end()) {
			cout << "없음\n";
		}
		else {
			
			
			cout << *finded << endl; 
		}
		

	}


	
}


==============================================================================================================================
저장한 시간: 2025-05-12 오후 6:54:46, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {


	save("main.cpp");
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	
	// [문제] 단어들에서 길이가 5인 것들만 화면에 출력하라
	for (const STRING& w : words) {
		if (w.size() == 5)
			cout << w << endl;
	}

	
}

==============================================================================================================================
저장한 시간: 2025-05-12 오후 7:03:14, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {


	save("main.cpp");
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	
	// [문제] 단어들에서 길이가 5인 것들만 화면에 출력하라

	copy(words.begin(), words.end(), 
				ostream_iterator<STRING>{cout}
	);

	// 다음시간에 계속...

	
}

==============================================================================================================================
저장한 시간: 2025-05-12 오후 7:03:54, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {


	save("main.cpp");
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	
	// [문제] 단어들에서 길이가 5인 것들만 화면에 출력하라

	copy(words.begin(), words.end(), 
				ostream_iterator<STRING>{cout, "\n"}
	);

	// 다음시간에 계속...!!!!!!!!!!!

	
}

==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:18:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025/1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 5/12 월요일 - 졸업작품 예정(16:00~) 끝나는 대로 수업
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {


	save("main.cpp");
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	
	// [문제] 단어들에서 길이가 5인 것들만 화면에 출력하라

	copy(words.begin(), words.end(), 
				ostream_iterator<STRING>{cout, "\n"}
	);

	// 다음시간에 계속...!!!!!!!!!!!

		
}


==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:39:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<fstream>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {


	
	// [문제] "main.cpp"의 단어를 list에 모두 저장하라


	ifstream in{ "main.cpp" };
	if (not in) {
		return 90909090;
	}

	list<STRING> words{ istream_iterator<STRING>{in},{} };
	
	// [문제] 단어들에서 길이가 5인 것들만 화면에 출력하라

	/*copy(words.begin(), words.end(), 
				ostream_iterator<STRING>{cout, "\n"}
	);*/

	STRING w;
	cout << "찾을 단어는: ";
	cin >> w;
	auto finded = find(words.begin(), words.end(), w);
	if (finded == words.end()) {
		cout << "없음\n";
	}
	else {
		cout << distance(words.begin(), finded) + 1 << "번째 단어:" << endl;
		cout << *finded << endl;
	}


	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:46:25, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>

//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	list<STRING> ToDo1{"게임", "밥먹기", "설거지", "청소", "게임2"};
	list<STRING> ToDo2{"음주", "운동", "잠자기", "과제", "c++", "백준"};
	ToDo1.merge(ToDo2);
	
	for (const STRING& s : ToDo1)
		cout << s << endl;

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:49:47, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>

//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	list<STRING> ToDo1{ "3333333", "55555", "1111111111", "9", "777" };
	list<STRING> ToDo2{ "0000000000", "88", "6666", "22222222", "4444444" };
	ToDo1.merge(ToDo2);

	for (const STRING& s : ToDo1)
		cout << s << endl;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:51:48, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>

//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	list<STRING> ToDo1{ "3333333", "55555", "1111111111", "9", "777" };
	list<STRING> ToDo2{ "0000000000", "88", "6666", "22222222", "444444" };
	ToDo1.sort();
	ToDo2.sort();

	ToDo1.merge(ToDo2);

	for (const STRING& s : ToDo1)
		cout << s << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:53:56, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<string>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	list<string> ToDo1{ "3333333", "55555", "1111111111", "9", "777" };
	list<string> ToDo2{ "0000000000", "88", "6666", "22222222", "444444" };
	ToDo1.sort();
	ToDo2.sort();

	ToDo1.merge(ToDo2);

	for (const string& s : ToDo1)
		cout << s << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-15 오후 5:55:59, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>
#include<string>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	list<string> ToDo1{ "333", "5", "11111", "9", "777" };
	list<string> ToDo2{ "0000000000", "88", "6666", "22222222", "444444" };
	ToDo1.sort();
	ToDo2.sort();

	ToDo1.merge(ToDo2);

	for (const string& s : ToDo1)
		cout << s << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-15 오후 6:11:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
// 
//----------------------------------------------------------------------------
// STL container - Containers are objects that store other objects.
// array<T, N> - 유일하게 크기가 고정
// vector<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			push_back도 O(1)
// deque<T> - random access가 가능, []연산자 제공O(1)시간에 access 가능, 
//			O(1) push_front, push_back
// List<T> - O(1) insert, delete, 자료 구조를 활용한 전용 함수 제공
//														(remove, sort, splice)
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<list>

//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	list<STRING> ToDo1{ "333", "5", "11111", "9", "777" };
	list<STRING> ToDo2{ "0000000000", "88", "6666", "22222222", "444444" };
	ToDo1.sort();
	ToDo2.sort();

	ToDo1.merge(ToDo2);

	for (const STRING& s : ToDo1)
		cout << s << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-15 오후 7:03:23, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 서로 다른 자료구조에서 c++프로그램이 동일한 방식으로
//			가능하게 해주는 것
// Iterators are a generalization of pointers that allow a C++ program to work 
// with different data structures in a uniform manner.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	STRING s{ "2025. 5. 15" };

	for (char c : s)
		cout << c << "----";
	cout << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 5:29:00, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 서로 다른 자료구조에서 c++프로그램이 동일한 방식으로
//			가능하게 해주는 것
// Iterators are a generalization of pointers that allow a C++ program to work 
// with different data structures in a uniform manner.
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	string s{ "2025. 5. 15" };


	// [예고] s를 거꾸로 출력하시오
	for (auto i = s.rbegin();i!=s.rend();++i )
		cout << *i << "----";
	cout << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 6:01:53, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 서로 다른 자료구조에서 c++프로그램이 동일한 방식으로
//			가능하게 해주는 것
// Iterators are a generalization of pointers that allow a C++ program to work 
// with different data structures in a uniform manner.
// 역방향 반복자는 반드시 class로만 만들 수 있다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<span>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	//STRING s{ "2025. 5. 15" };

	int a[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	span<int>s{ a };
	// [예고] s를 거꾸로 출력하시오
	for (auto i = s.rbegin(); i!=s.rend(); ++i )
		cout << *i << " ";
	cout << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 6:03:29, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 서로 다른 자료구조에서 c++프로그램이 동일한 방식으로
//			가능하게 해주는 것
// Iterators are a generalization of pointers that allow a C++ program to work 
// with different data structures in a uniform manner.
// 역방향 반복자는 반드시 class로만 만들 수 있다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<span>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	//STRING s{ "2025. 5. 15" };

	int s[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	//span<int>s{ a };
	// [예고] s를 거꾸로 출력하시오
	for (auto i = rbegin(s); i!= rend(s); ++i )
		cout << *i << " ";
	cout << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 6:22:59, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 서로 다른 자료구조에서 c++프로그램이 동일한 방식으로
//			가능하게 해주는 것
// Iterators are a generalization of pointers that allow a C++ program to work 
// with different data structures in a uniform manner.
// 역방향 반복자는 반드시 class로만 만들 수 있다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<span>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	STRING s{ "2025. 5. 15" };

	// [예고] s를 거꾸로 출력하시오
	for (auto i = rbegin(s); i!= rend(s); ++i )
		cout << *i << " ";
	cout << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 6:23:56, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 서로 다른 자료구조에서 c++프로그램이 동일한 방식으로
//			가능하게 해주는 것
// Iterators are a generalization of pointers that allow a C++ program to work 
// with different data structures in a uniform manner.
// 역방향 반복자는 반드시 class로만 만들 수 있다
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<vector>
#include<span>
//----------------------------------------------------------------------------

extern bool 관찰;



int main() {

	STRING s{ "2025. 5. 15" };

	// [예고] s를 거꾸로 출력하시오
	for (auto i = s.rbegin(); i!= s.rend(); ++i )
		cout << *i << " ";
	cout << endl;

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 6:42:36, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

int main() {

	ostream_iterator<char> p{cout};

	cout << sizeof(p);

	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 6:45:10, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

int main() {

	ostream_iterator<char> p{cout};

	*p = 'a';
	++p;
	*p = 'B';
	++p;
	*p = 'c';
	++p;
	*p = 'd';
	++p;
	*p = '\n';


	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-19 오후 7:03:58, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category


void f(const ostream_iterator<char>& p) 
{
	cout << typeid(ostream_iterator<char>::iterator_category).name() << endl;
}

int main() {
	// [문제] 함수f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다
	// 함수f를 정의하라
	
	f(ostream_iterator<char>{cout});
	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-22 오후 5:30:42, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category


void f(const ostream_iterator<char>& p) 
{
	cout << typeid(ostream_iterator<char>::iterator_category).name() << endl;
}

void f(const istream_iterator<int>& p)
{
	cout << typeid(istream_iterator<int>::iterator_category).name() << endl;
}

int main() {
	// [문제] 함수f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다
	// 함수f를 정의하라
	
	f(ostream_iterator<char>{cout});
	f(istream_iterator<int>{cin});
	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 5:35:43, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	// [문제] 함수f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다
	// 함수f를 정의하라
	
	f(ostream_iterator<char>{cout});
	//f(istream_iterator<int>{cin});
	
	f(forward_list<char>{}.begin());
	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 5:38:27, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	// [문제] 함수f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다
	// 함수f를 정의하라
	
	f(ostream_iterator<char>{cout});
	//f(istream_iterator<int>{cin});
	
	f(forward_list<char>{}.begin());
	f(list<int>::iterator{ });
	deque<STRING> d;
	f(d.rbegin());
	f(vector<int>{}.cbegin());
	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 5:49:46, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

int main() {
	// [문제] 함수f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다
	// 함수f를 정의하라
	
	f(ostream_iterator<char>{cout});
	//f(istream_iterator<int>{cin});
	
	f(forward_list<char>{}.begin());
	f(list<int>::iterator{ });
	deque<STRING> d;
	f(d.rbegin());
	f(vector<int>{}.cbegin());
	int* p;
	f(p);
	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 5:56:35, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	// [문제] 함수f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력한다
	// 함수f를 정의하라
	
	// vector의 반복자가 contiguous임을 판단 하거나 출력하고 싶다
	f(vector<int>{}.cbegin());



	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 6:05:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	STRING s;

	f(s.begin());

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 6:24:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	STRING s;

	f(s.rbegin());

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 6:30:04, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	STRING s;
	
	f(s.begin());

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 6:30:25, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<forward_list>
#include<list>
#include<deque>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;

}

int main() {
	STRING s;
	
	f(s.begin());

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 6:53:51, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;

}

int main() {
	STRING s{"the quick brown fox jumps over the lazy dog"};
	sort(s.begin(), s.end());

	cout << s;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-22 오후 6:56:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

template<class 반복자>
void f(const 반복자& p)
{
	cout << typeid(반복자::iterator_category).name() << endl;

}

int main() {
	STRING s{"the quick brown fox jumps over the lazy dog"};
	sort(s.begin(), s.end());

	cout << s;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:16:20, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자 - 각 컨테이너가 자기가 관리하는 원소를 처음부터 끝까지 빠짐없이 순회 할 수 있도록
//			제공하는 인터페이스
// 컨테이너에 따라서(자료 구조가 서로 다르기 때문에) 반복자가 할 수 있는 일이 서로 다름
// 
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<iterator>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

//반복자는 서로 다르다 - 6개의 category

int main() {
	STRING s{"the quick brown fox jumps over the lazy dog"};
	sort(s.begin(), s.end());
	/*
	- 알고리즘 sort는 랜덤 반복자를 전달 받아야함
	- 따라서 s.begin, s.end는 랜덤반복자가 지원해야만 하는 모든 연산을 제공 하여야 한다
	- 나는 sort가 필요로 하는 연산자만 제공*/
	cout << s;

	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:27:50, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	STRING s("2025. 5. 26");
	
	// 한 글자를 입력받아 s에 있는지 없는지, 있다면 몇번째 글자인지 출력하라
	cout << "찾는 글자는: ";
	char c;
	cin >> c;
	auto p = find(s.begin(), s.end(), c);
	if (p != s.end()) {
		cout << *p << endl;
		// 만일 random_access_iterator_tag라면 위치는
		//p - s.begin() + 1;
		// 아니라면 루프를 돌며 개수를 새 나아가야함
		
		// 위와 같이 동작하는 것이 distance 함수
		cout << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
	}
	else {
		cout << "없음\n";
	}


	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:47:11, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class iter, class target>
iter myfind(iter start, iter end, target val);

int main() {
	STRING s("2025. 5. 26");
	
	// 한 글자를 입력받아 s에 있는지 없는지, 있다면 몇번째 글자인지 출력하라
	cout << "찾는 글자는: ";
	char c;
	cin >> c;
	auto p = find(s.begin(), s.end(), c);
	cout << "원래문장: " << s << endl;
	if (p != s.end()) {
		// 만일 random_access_iterator_tag라면 위치는
		//p - s.begin() + 1;
		// 아니라면 루프를 돌며 개수를 새 나아가야함
		
		// 위와 같이 동작하는 것이 distance 함수
		cout << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
	}
	else {
		cout << "없음\n";
	}


	save("main.cpp");
}
template<class iter, class target>
iter myfind(iter start, iter end, target val)
{
	if (start == end) return start;

	for (auto now = start;now != end; ++now) {
		if (*now == val)
			return now;
	}
	return end;
	
}


==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:48:14, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class iter, class target>
iter myfind(iter start, iter end, target val);

int main() {
	STRING s("2025. 5. 26");
	
	// 한 글자를 입력받아 s에 있는지 없는지, 있다면 몇번째 글자인지 출력하라
	cout << "찾는 글자는: ";
	char c;
	cin >> c;
	auto p = myfind(s.begin(), s.end(), c);
	cout << "원래문장: " << s << endl;
	if (p != s.end()) {
		// 만일 random_access_iterator_tag라면 위치는
		//p - s.begin() + 1;
		// 아니라면 루프를 돌며 개수를 새 나아가야함
		
		// 위와 같이 동작하는 것이 distance 함수
		cout << distance(s.begin(), p) + 1 << "번째 문자입니다" << endl;
	}
	else {
		cout << "없음\n";
	}


	save("main.cpp");
}
template<class iter, class target>
iter myfind(iter start, iter end, target val)
{
	if (start == end) return start;

	for (auto now = start;now != end; ++now) {
		if (*now == val)
			return now;
	}
	return end;
	
}



==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:50:46, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class iter, class target>
iter myfind(iter start, iter end, target val);

int main() {
	STRING s("2025. 5. 26");
	
	// [문제]3보다 큰 숫자를 찾아라
	auto p = find_if(s.begin(), s.end(), [](char c) {
		return '3' < c;
		});

	if (p != s.end()) {
		cout << "3보다 큰" << *p << "를 찾았다\n";
	}
	else {
		cout << "3보다 큰건 없어\n";
	}


	save("main.cpp");
}
template<class iter, class target>
iter myfind(iter start, iter end, target val)
{
	if (start == end) return start;

	for (auto now = start;now != end; ++now) {
		if (*now == val)
			return now;
	}
	return end;
	
}


==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:51:05, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class iter, class target>
iter myfind(iter start, iter end, target val);

int main() {
	STRING s("01011110100111101010101101010101010100010101010101010101010110");
	
	// [문제]3보다 큰 숫자를 찾아라
	auto p = find_if(s.begin(), s.end(), [](char c) {
		return '3' < c;
		});

	if (p != s.end()) {
		cout << "3보다 큰" << *p << "를 찾았다\n";
	}
	else {
		cout << "3보다 큰건 없어\n";
	}


	save("main.cpp");
}
template<class iter, class target>
iter myfind(iter start, iter end, target val)
{
	if (start == end) return start;

	for (auto now = start;now != end; ++now) {
		if (*now == val)
			return now;
	}
	return end;
	
}


==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:57:07, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class iter, class how>
iter myfind_if(iter start, iter end, how func);
//									 이 자리는 정확하게는 호출가능 타입이다
int main() {
	STRING s("01011110100111101010101101010101010100010101010101010101010110");
	
	// [문제]3보다 큰 숫자를 찾아라
	auto p = find_if(s.begin(), s.end(), [](char c) {
		return '3' < c;
		});

	if (p != s.end()) {
		cout << "3보다 큰" << *p << "를 찾았다\n";
	}
	else {
		cout << "3보다 큰건 없어\n";
	}


	save("main.cpp");
}

template<class iter, class how>
iter myfind_if(iter start, iter end, how func) {
	for (auto now = start; now != end; ++now) {
		if (func(*now))
			return now;
	}

	//수업에서는 아래 코드 사용
	/*
	while(start!=end)
		if(func(*start))
			return start;
		++start;
	*/
	return end;
}

==============================================================================================================================
저장한 시간: 2025-05-26 오후 6:58:15, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class iter, class how>
iter myfind_if(iter start, iter end, how func);
//									 이 자리는 정확하게는 호출가능 타입이다
int main() {
	STRING s("01011110100111101010101101010101010100010101010101010101010110");
	
	// [문제]3보다 큰 숫자를 찾아라
	auto p = find_if(s.begin(), s.end(), [](char c) {
		return '3' < c;
		});

	if (p != s.end()) {
		cout << "3보다 큰" << *p << "를 찾았다\n";
	}
	else {
		cout << "3보다 큰건 없어\n";
	}


	save("main.cpp");
}

template<class iter, class how>
iter myfind_if(iter start, iter end, how func) {
	for (auto now = start; now != end; ++now) {
		if (func(*now) == true)//이런 callable을 predicate
			return now;
	}

	//수업에서는 아래 코드 사용
	/*
	while(start!=end)
		if(func(*start))
			return start;
		++start;
	*/
	return end;
}

==============================================================================================================================
저장한 시간: 2025-05-26 오후 7:00:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	STRING s("2025. 5. 26");

	// [문제] s가 관리하는 문자들을 화면에 출력하라
	// == 화면에 복사하라
	copy(s.begin(), s.end(), ostream_iterator<char>{cout});
	


	save("main.cpp");
}


==============================================================================================================================
저장한 시간: 2025-05-26 오후 7:02:40, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	STRING s("2025. 5. 26");
	
	vector<char> v;
	
	// [문제] s가 관리하는 문자들을 v에 복사하라
	save("main.cpp");
	copy(s.begin(), s.end(), v.begin());


	
}


==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:31:07, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	STRING s("2025. 5. 26");

	vector<char> v(s.size());

	// [문제] s가 관리하는 문자들을 v에 복사하라

	copy(s.begin(), s.end(), v.begin());
	for (char c : v)
		cout << c;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:31:54, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	STRING s("2025. 5. 26");

	vector<char> v;
	v.reserve(s.size());

	// [문제] s가 관리하는 문자들을 v에 복사하라

	copy(s.begin(), s.end(), v.begin());
	for (char c : v)
		cout << c;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:38:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	STRING s("2025. 5. 26");

	vector<char> v;
	v.reserve(s.size());
	cout << v.size() << endl;
	// [문제] s가 관리하는 문자들을 v에 복사하라

	copy(s.begin(), s.end(), v.begin());
	for (char c : v)
		cout << c;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:40:00, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	STRING s("2025. 5. 26");

	vector<char> v;
	// [문제] s가 관리하는 문자들을 화면에 복사하라
	copy(s.begin(), s.end(), ostream_iterator<char>{cout});

	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:47:28, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest);


int main() {
	STRING s("2025. 5. 26");

	vector<char> v;
	// [문제] s가 관리하는 문자들을 화면에 복사하라
	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});

	save("main.cpp");
}

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest) {
	while (start not_eq end) {
		*dest = *start;
		++start;
		++dest;
	}
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:49:44, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest);


int main() {
	STRING s("2025. 5. 26");

	vector<char> v;
	// [문제] s가 관리하는 문자들을 화면에 복사하라
	//my_copy(s.begin(), s.end(), v.begin());
	for (const char& c : s)
		cout << c;
	cout<<endl;
	save("main.cpp");
}

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest) {
	while (start not_eq end) {
		*dest = *start; // 여기서 사망
		++start;
		++dest;
	}
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 5:59:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest);


int main() {
	STRING s("2025. 5. 26");

	vector<char> v;
	v.reserve(s.size());
	// [문제] s가 관리하는 문자들을 화면에 복사하라
	my_copy(s.begin(), s.end(), v.begin());
	for (int i = 0; i < s.size(); ++i) {
		cout << v[i];
	}
	save("main.cpp");
}

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest) {
	while (start not_eq end) {
		*dest = *start; // 여기서 사망
		++start;
		++dest;
	}
	
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 6:01:41, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// 반복자와 알고리즘
// find
// find_if
// copy
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<algorithm>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest);

int main() {
	STRING s("2025. 5. 26");

	vector<char> v;

	my_copy(s.begin(), s.end(), back_inserter(v));
	
	for (char c : v)
		cout << c;

	save("main.cpp");
}

template<class InIter, class Dest>
void my_copy(InIter start, InIter end, Dest dest) {
	while (start not_eq end) {
		*dest = *start; // 여기서 사망
		++start;
		++dest;
	}
	
}

==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:00:33, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v;
	v.reserve( 10'000);
	STRING temp;

	while (in >> temp)
		v.push_back(temp);
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:01:00, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v;
	//v.reserve( 10'000);
	STRING temp;

	while (in >> temp)
		v.push_back(temp);
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:02:14, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v;
	v.reserve( 100'000);
	STRING temp;

	while (in >> temp)
		v.push_back(temp);
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:03:01, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v;
	v.reserve( 30'000);
	STRING temp;

	while (in >> temp)
		v.push_back(temp);
	
	cout << v.size();
	
	save("main.cpp");
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:04:43, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v{ istream_iterator<STRING>{in}, {} };
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:05:08, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:06:08, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	vector<STRING> v{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// 하지만 associative에서는 괜찮다
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-05-29 오후 7:06:26, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. vector<STRING> v;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -336558966555;
	}

	set<STRING> v{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// 하지만 associative에서는 괜찮다
	cout << v.size();
	
	save("main.cpp");
	관찰 = true;
}



==============================================================================================================================
저장한 시간: 2025-06-02 오후 5:37:39, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	// 기본 operator<가 정의되어 있는 객체라면 원소로 관리 가능하다
	set<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// 하지만 associative에서는 괜찮다
	for (const STRING& word : s)
		cout << word << endl;
	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 5:47:47, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

template<>
struct less<STRING> {
	bool operator()(const STRING& lhs, const STRING& rhs) const{
		return lhs.size() < rhs.size();
	}
};

int main() {
	
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	set<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// 이때 사용자 정의 자료형 STRING을 저장하는 set은
	// 1. less<STRING>이 정의되어 있는지 찾는다
	// 2. operator<를 찾는다




	for (const STRING& word : s)
		cout << word << endl;
	
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 5:53:15, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	set<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 소설에 있는 단어인지 알려주자
	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		auto f = find(s.begin(), s.end(), word);
		if (f != s.end()) {
			cout << "찾았습니다\n";
			cout << distance(s.begin(), f) << "번째 단어 입니다\n";
		}
		else {
			cout << "그런건 없다\n";
		}
	}
	save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 5:54:33, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	set<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 소설에 있는 단어인지 알려주자
	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		auto f = find(s.begin(), s.end(), word);
		if (f != s.end()) {
			cout << "찾았습니다\n";
			cout << distance(s.begin(), f) << "번째 단어 입니다\n";
		}
		else {
			cout << "그런건 없다\n";
		}
	}
	//save("main.cpp");
	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:27:46, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 소설에 w있는 단어인지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;

	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		auto f = s.find(word);
		if (f != s.end()) {
			cout << "찾았습니다\n";
			cout << distance(s.begin(), f)+1 << "번째 단어 입니다\n";
		}
		else {
			cout << "그런건 없다\n";
		}
	}
	
	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:31:48, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 소설에 w있는 단어인지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;


	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:33:13, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 그 단어가 몇 개 있는지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;

	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		size_t cnt = s.count(word);
		if (cnt == 0) {
			cout << "찾는 단어가 없습니다\n";
		}
		else {
			cout << cnt << "번 사용되었습니다.\n";
		}
	}

	
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:41:26, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 그 단어가 몇 개 있는지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;

	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		cout << s.count(word) << "번 사용되었습니다.\n";
	}
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:43:37, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 그 단어가 몇 개 있는지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;

	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		cout << s.count(word) << "번 사용되었습니다.\n";
		//이 코드는 다음을 포장한 것이다
		pair<multiset<STRING>::const_iterator,
			multiset<STRING>::const_iterator> 하한과상한
			= s.equal_range(word);
		cout << distance(하한과상한.first, 하한과상한.second);

	}
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:43:59, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 그 단어가 몇 개 있는지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;

	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		cout << s.count(word) << "번 사용되었습니다.\n";
		//이 코드는 다음을 포장한 것이다
		pair<multiset<STRING>::const_iterator,
			multiset<STRING>::const_iterator> 하한과상한
			= s.equal_range(word);
		cout << distance(하한과상한.first, 하한과상한.second) << "번 사용되었습니다.\n";

	}
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 6:46:08, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<vector>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;

//template<>
//struct less<STRING> {
//	bool operator()(const STRING& lhs, const STRING& rhs) const{
//		return lhs.size() < rhs.size();
//	}
//};

int main() {
	save("main.cpp");
	// 이상한나라의 엘리스를 다운받는다
	// 1. set<STRING> s;에 저장하라
	// 2. 모두 몇 단어로 만들었는지 출력하라
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}

	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	// [문제] 단어를 입력받아서, 그 단어가 몇 개 있는지 알려주자

	for (const STRING& w : s)
		cout << w << " ";
	cout << endl;

	while (true) {
		cout << "찾는 단어: ";
		STRING word;
		cin >> word;
		cin.clear();
		cout << s.count(word) << "번 사용되었습니다.\n";
		//이 코드는 다음을 포장한 것이다
		 auto [하한, 상한] = s.equal_range(word);
		cout << distance(하한, 상한) << "번 사용되었습니다.\n";

	}
}

==============================================================================================================================
저장한 시간: 2025-06-02 오후 7:01:27, 월요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<array>
#include<set>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	save("main.cpp");
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	array<size_t, 26> alphaNum{};
	for (const STRING w : s) {
		for (char c : w) {
			if(isalpha(c)){
				c = tolower(c);
				alphaNum[c - 'a']++;
			}
		}
	}

	for (int i = 0; i < alphaNum.size(); ++i) {
		cout << char('a' + i) << " - " << alphaNum[i] << endl;
	}
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 5:32:14, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<set>
#include<map>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 
	// 연괸된 횟수를 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	map<char, size_t> alphaAndCnt;
	for( const STRING& word : s){
		for (char c : word) {
			alphaAndCnt[c]++;
		}
	}
	for (pair<char, size_t> p: alphaAndCnt) {
		cout << p.first << " - " << p.second << endl;
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 5:33:12, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<set>
#include<map>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 
	// 연괸된 횟수를 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	map<char, size_t> alphaAndCnt;
	for( const STRING& word : s){
		for (char c : word) {
			if (isalpha(c)) {
				alphaAndCnt[tolower(c)]++;
			}
		}
	}
	for (pair<char, size_t> p: alphaAndCnt) {
		cout << p.first << " - " << p.second << endl;
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 5:46:57, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<set>
#include<map>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 
	// 연괸된 횟수를 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	map<char, size_t> alphaAndCnt;
	for( const STRING& word : s){
		for (char c : word) {
			if (isalpha(c)) {
				alphaAndCnt[tolower(c)]++;
			}
		}
	}
	for (auto [lower, cnt] : alphaAndCnt) {
		cout << lower << " - " << cnt << endl;
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 5:49:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<set>
#include<map>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 
	// 연괸된 횟수를 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	map<char, size_t> alphaAndCnt;
	for( const STRING& word : s){
		for (char c : word) {
			if (isalpha(c)) {
				alphaAndCnt[tolower(c)]++;
			}
		}
	}
	//개수기준 내림차순으로 정렬
	map<size_t, char> cntAndAlpha;
	for (auto [lower, cnt] : alphaAndCnt)
		cntAndAlpha[cnt] = lower;
	
	for (auto [cnt, lower] : cntAndAlpha)
		cout << cnt << " - " << lower << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 5:49:50, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<set>
#include<map>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 
	// 연괸된 횟수를 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	map<char, size_t> alphaAndCnt;
	for( const STRING& word : s){
		for (char c : word) {
			if (isalpha(c)) {
				alphaAndCnt[tolower(c)]++;
			}
		}
	}
	//개수기준 내림차순으로 정렬
	map<size_t, char> cntAndAlpha;
	for (auto [lower, cnt] : alphaAndCnt)
		cntAndAlpha[cnt] = lower;
	
	for (auto [cnt, lower] : cntAndAlpha)
		cout << lower << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 5:51:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<set>
#include<map>
#include<algorithm>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250602;
	}
	
	multiset<STRING, less<STRING>> s{ istream_iterator<STRING>{in}, {} }; // 사용하지 말것
	
	// [문제] 멀티셋에 저장된 모든 알파벳의 사용 횟수를 다음과 같이 
	// 연괸된 횟수를 내림차순으로 출력하라
	// 대문자는 소문자로 바꾸어 취급한다
	// a - 320
	// b - 645
	// ...
	// z - 2
	map<char, size_t> alphaAndCnt;
	for( const STRING& word : s){
		for (char c : word) {
			if (isalpha(c)) {
				alphaAndCnt[tolower(c)]++;
			}
		}
	}
	//개수기준 내림차순으로 정렬
	map<size_t, char, greater<size_t>> cntAndAlpha;
	for (auto [lower, cnt] : alphaAndCnt)
		cntAndAlpha[cnt] = lower;
	
	for (auto [cnt, lower] : cntAndAlpha)
		cout << lower << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:02:02, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<map>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250605;
	}
	// [문제] 소설에 사용된 단어의 출현 횟수를 알고싶다
	//다음과 같은 형식으로 출력해 보자
	//
	//the - 1557
	//a - 1000
	//...
	//zigzag - 1
	map<STRING, size_t> words;
	STRING word;
	while (in >> word) {
		words[word]++;
	}
	map<size_t, STRING, greater<size_t>> sdrow;
	for (auto [w, cnt] : words) {
		sdrow[cnt] = w;
	}
	for (auto [cnt, w] : sdrow)
		cout << w << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:03:02, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<map>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250605;
	}
	// [문제] 소설에 사용된 단어의 출현 횟수를 알고싶다
	//다음과 같은 형식으로 출력해 보자
	//
	//the - 1557
	//a - 1000
	//...
	//zigzag - 1
	map<STRING, size_t> words;
	STRING word;
	while (in >> word) {
		words[word]++;
	}
	for (auto [w, cnt] : words)
		cout << w << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:03:12, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<map>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250605;
	}
	// [문제] 소설에 사용된 단어의 출현 횟수를 알고싶다
	//다음과 같은 형식으로 출력해 보자
	//
	//the - 1557
	//a - 1000
	//...
	//zigzag - 1
	map<STRING, size_t> words;
	STRING word;
	while (in >> word) {
		words[word]++;
	}
	map<size_t, STRING, greater<size_t>> sdrow;
	for (auto [w, cnt] : words) {
		sdrow[cnt] = w;
	}
	for (auto [cnt, w] : sdrow)
		cout << w << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:20:04, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<fstream>
#include<map>
#include<random>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (not in)
	{
		cout << "파일 읽기 실패\n\n";
		return -20250605;
	}
	// [문제] 소설에 사용된 단어의 출현 횟수를 알고싶다
	//다음과 같은 형식으로 출력해 보자
	//
	//the - 1557
	//a - 1000
	//...
	//zigzag - 1
	map<STRING, size_t> words;
	STRING word;
	while (in >> word) {
		words[word]++;
	}
	multimap<size_t, STRING, greater<size_t>> sdrow;
	for (auto [w, cnt] : words) {
		sdrow.insert(pair<size_t, STRING>{cnt, w}); // 이게 정식
		sdrow.insert(make_pair(cnt, w)); // 편의함수 사용

		//sdrow[cnt] = w; unique key 일때만 허용되는 sugar

	}
	for (auto [cnt, w] : sdrow)
		cout << w << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:28:51, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
array<int, 20'250'605> a;

int main() {
	for (int& num : a)
		num = uid(dre);
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 10'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		cout << range << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:29:08, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
array<int, 20'250'605> a;

int main() {
	for (int& num : a)
		num = uid(dre);
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 100'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		cout << range << " - " << cnt << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:33:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
#include<print>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
//normal_distribution nd{ 0, 999'999 };
array<int, 20'250'605> a;

int main() {
	for (int& num : a)
		num = uid(dre);
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 50'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		println("[{:2}] - {}",range,cnt);
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:37:18, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
#include<print>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
normal_distribution nd;
array<int, 20'250'605> a;

int main() {
	//for (int& num : a)
	//	num = uid(dre);
	//map<int, size_t> rangeAndCnt;
	//for (int num : a) {
	//	rangeAndCnt[num / 50'000]++;
	//}
	//for (auto [range, cnt] : rangeAndCnt)
	//	println("[{:2}] - {}",range,cnt);
	for (int i = 0; i < 10; ++i) {
		cout << nd(dre) << endl;
	}
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:42:28, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
#include<print>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
normal_distribution nd;
array<int, 20'250'605> a;

int main() {

	for (int& num : a){
		double d = nd(dre);
		d *= 200'000;
		d += 500'000;
		
		if(0<=d && d<1'000'000)
			num = (int)d;	
	}
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 50'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		println("[{:2}] - {}",range,cnt);
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:43:11, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
#include<print>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
normal_distribution nd{ 0.0, 0.5};
array<int, 20'250'605> a;

int main() {

	for (int& num : a){
		double d = nd(dre);
		d *= 200'000;
		d += 500'000;
		
		if(0<=d && d<1'000'000)
			num = (int)d;	
	}
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 50'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		println("[{:2}] - {}",range,cnt);
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:43:48, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
#include<print>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
normal_distribution nd{ 0.0, 0.01};
array<int, 20'250'605> a;

int main() {

	for (int& num : a){
		double d = nd(dre);
		d *= 200'000;
		d += 500'000;
		
		if(0<=d && d<1'000'000)
			num = (int)d;	
	}
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 50'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		println("[{:2}] - {}",range,cnt);
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 6:44:14, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// associative container
//	- set<key>			: key와 value를 구분하지 않는 컨테이너
//	- map<Key, Value>	: 아이돌 그룹 - 멤버
//						  모델링 - 텍스처
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<map>
#include<random>
#include<array>
#include<print>
//----------------------------------------------------------------------------

extern bool 관찰;

// [문제] uniform분포는 uniform한가?
// [문제] normal분포는 normal한가?

default_random_engine dre;			//mt19937 엔진
uniform_int_distribution uid{0, 999'999};
normal_distribution nd{ 0.0, 0.025};
array<int, 20'250'605> a;

int main() {

	for (int& num : a){
		double d = nd(dre);
		d *= 200'000;
		d += 500'000;
		
		if(0<=d && d<=1'000'000)
			num = (int)d;	
	}
	map<int, size_t> rangeAndCnt;
	for (int num : a) {
		rangeAndCnt[num / 50'000]++;
	}
	for (auto [range, cnt] : rangeAndCnt)
		println("[{:2}] - {}",range,cnt);
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 7:01:32, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// unordered associative container - hash 기반
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<unordered_set>
#include<string>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	unordered_set<string> us{"1", "22", "333", "4444", "55555"};
	for (const string& s : us)
		cout << s << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 7:02:15, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// unordered associative container - hash 기반
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<unordered_set>
#include<string>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	unordered_set<string> us{"1", "22", "333", "4444", "55555"};
	us.insert("666666");
	for (const string& s : us)
		cout << s << endl;
	save("main.cpp");
}

==============================================================================================================================
저장한 시간: 2025-06-05 오후 7:03:34, 목요일
==============================================================================================================================

//----------------------------------------------------------------------------
// 2025 / 1학기 STL
// 6/19 목요일 15주2일 - 기말시험
//----------------------------------------------------------------------------
// unordered associative container - hash 기반
//----------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include"STRING.h"
using namespace std;
//----------------------------------------------------------------------------
#include<unordered_set>
#include<string>
//----------------------------------------------------------------------------

extern bool 관찰;


int main() {
	unordered_set<string> us{"1", "22", "333", "4444", "55555"};
	us.insert("666666");
	for (const string& s : us)
		cout << s << endl;
	cout << std::hash<string>{}("666666") << endl;
	cout << std::hash<string>{}("4444") << endl;
	save("main.cpp");
}